import React, { useState, useEffect, Suspense, useRef, useMemo, useCallback } from 'react';
import { motion } from 'framer-motion';
import { DataProcessingService } from '../../../services/DataProcessingService';
import { useNotification } from '../../../contexts/NotificationContext';
import { LazyVisualizationWrapper } from '../../../components/shared/LazyVisualization';
import { MessageMarkdown } from './MessageMarkdown';
import { TableFormatter } from '../../../services/TableFormatter';
import { TableVisualization } from '../../../Visualization/tables/TableVisualization';

// Helper function to map our internal chart types to the expected chart types
function mapChartType(type: string): string {
  // Normalize the input type by removing underscores and converting to lowercase
  const normalizedType = type.toLowerCase().replace(/_/g, '').replace(/chart$/, '');
  
  // Debug log for chart type mapping
  console.debug(`[Chart Type Mapping] Original: "${type}", Normalized: "${normalizedType}"`);
  
  const typeMap: Record<string, string> = {
    'bar': 'bar',
    'barchart': 'bar',
    'bar_chart': 'bar',
    'line': 'line',
    'linechart': 'line',
    'line_chart': 'line',
    'pie': 'pie',
    'piechart': 'pie',
    'pie_chart': 'pie',
    'area': 'area',
    'areachart': 'area',
    'area_chart': 'area',
    'scatter': 'scatter',
    'scatterchart': 'scatter',
    'scatter_chart': 'scatter',
    'composed': 'composed',
    'composedchart': 'composed',
    'composed_chart': 'composed',
    'heatmap': 'heatmap',
    'heatmapchart': 'heatmap',
    'radar': 'radar',
    'radarchart': 'radar',
    'radar_chart': 'radar',
    'funnel': 'funnel',
    'funnelchart': 'funnel',
    'funnel_chart': 'funnel',
    'treemap': 'treemap',
    'treemapchart': 'treemap',
    'treemap_chart': 'treemap',
    'network': 'network',
    'networkgraph': 'network',
    'network_graph': 'network',
    'geospatial': 'geospatial',
    'geospatialmap': 'geospatial',
    'geospatial_map': 'geospatial',
    'sankey': 'sankey',
    'sankeydiagram': 'sankey',
    'sankey_diagram': 'sankey',
    'table': 'table'
  };
  
  // Try to match the normalized type first
  if (typeMap[normalizedType]) {
    const result = typeMap[normalizedType];
    console.debug(`[Chart Type Mapping] Matched normalized type: "${normalizedType}" â†’ "${result}"`);
    return result;
  }
  
  // If no match with normalized type, try the original type
  const result = typeMap[type] || type || 'bar';
  console.debug(`[Chart Type Mapping] Final result: "${result}"`);
  return result;
}

// Helper function to validate and normalize visualization types
function validateVisualizationType(type: string | undefined): string {
  console.log(`[DEBUG] validateVisualizationType called with type: "${type}"`);
  
  if (!type) {
    console.log('[DEBUG] No type provided, defaulting to "bar"');
    return 'bar'; // Default to bar if no type provided
  }
  
  // Check URL parameters for forced chart type
  try {
    const urlParams = new URLSearchParams(window.location.search);
    const forcedChartType = urlParams.get('chartType');
    if (forcedChartType) {
      console.log(`[DEBUG] Forcing chart type from URL parameter: "${forcedChartType}"`);
      return mapChartType(forcedChartType);
    }
  } catch (error) {
    console.error('Error checking URL parameters:', error);
  }
  
  // Get the mapped type
  const mappedType = mapChartType(type);
  console.log(`[DEBUG] Type "${type}" mapped to "${mappedType}"`);
  
  // List of all supported visualization types from the Visualization directory
  const supportedTypes = [
    'bar', 'line', 'pie', 'area', 'scatter', 'composed', 
    'heatmap', 'radar', 'funnel', 'treemap', 'network', 
    'geospatial', 'sankey', 'table'
  ];
  
  // Check if the mapped type is supported
  if (supportedTypes.includes(mappedType)) {
    console.log(`[DEBUG] Type "${mappedType}" is supported`);
    return mappedType;
  }
  
  // If not supported, log a warning and return a default
  console.warn(`[Visualization Type] Unsupported type: "${type}" (mapped to "${mappedType}"). Falling back to "bar".`);
  return 'bar';
}

// Loading placeholder for lazy-loaded components
const VisualizationLoader = () => (
  <div className="animate-pulse rounded-lg overflow-hidden">
    <div className="h-64 bg-gray-200 dark:bg-gray-700"></div>
    <div className="h-4 mt-3 bg-gray-200 dark:bg-gray-700 w-3/4 rounded"></div>
    <div className="h-3 mt-2 bg-gray-200 dark:bg-gray-700 w-1/2 rounded"></div>
  </div>
);

// Icons
// Step type icons imported from AnalyticalStep
const ChartBarIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
    <path strokeLinecap="round" strokeLinejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 0 1 3 19.875v-6.75ZM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V8.625ZM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V4.125Z" />
  </svg>
);

const FilterIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
    <path strokeLinecap="round" strokeLinejoin="round" d="M12 3c2.755 0 5.455.232 8.083.678.533.09.917.556.917 1.096v1.044a2.25 2.25 0 0 1-.659 1.591l-5.432 5.432a2.25 2.25 0 0 0-.659 1.591v2.927a2.25 2.25 0 0 1-1.244 2.013L9.75 21v-6.568a2.25 2.25 0 0 0-.659-1.591L3.659 7.409A2.25 2.25 0 0 1 3 5.818V4.774c0-.54.384-1.006.917-1.096A48.32 48.32 0 0 1 12 3Z" />
  </svg>
);

const AggregateIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
    <path strokeLinecap="round" strokeLinejoin="round" d="M7.5 14.25v2.25m3-4.5v4.5m3-6.75v6.75m3-9v9M6 20.25h12A2.25 2.25 0 0 0 20.25 18V6A2.25 2.25 0 0 0 18 3.75H6A2.25 2.25 0 0 0 3.75 6v12A2.25 2.25 0 0 0 6 20.25Z" />
  </svg>
);

const SortIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
    <path strokeLinecap="round" strokeLinejoin="round" d="M3 4.5h14.25M3 9h9.75M3 13.5h5.25m5.25-.75L17.25 9m0 0L21 12.75M17.25 9v12" />
  </svg>
);

const GroupIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
    <path strokeLinecap="round" strokeLinejoin="round" d="M2.25 7.125C2.25 6.504 2.754 6 3.375 6h6c.621 0 1.125.504 1.125 1.125v3.75c0 .621-.504 1.125-1.125 1.125h-6a1.125 1.125 0 0 1-1.125-1.125v-3.75ZM14.25 8.625c0-.621.504-1.125 1.125-1.125h5.25c.621 0 1.125.504 1.125 1.125v8.25c0 .621-.504 1.125-1.125 1.125h-5.25a1.125 1.125 0 0 1-1.125-1.125v-8.25ZM3.75 16.125c0-.621.504-1.125 1.125-1.125h5.25c.621 0 1.125.504 1.125 1.125v2.25c0 .621-.504 1.125-1.125 1.125h-5.25a1.125 1.125 0 0 1-1.125-1.125v-2.25Z" />
  </svg>
);

const InsightIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
    <path strokeLinecap="round" strokeLinejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18" />
  </svg>
);

const CompareIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
    <path strokeLinecap="round" strokeLinejoin="round" d="M7.5 21 3 16.5m0 0L7.5 12M3 16.5h13.5m0-13.5L21 7.5m0 0L16.5 12M21 7.5H7.5" />
  </svg>
);

const TableIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
    <path strokeLinecap="round" strokeLinejoin="round" d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
  </svg>
);

export interface AnalyticalStep {
  id: string;
  type: string;
  description: string;
  order: number;
  data?: any;
  content?: string;
  code?: string;
  insights?: string[];
  metrics?: Array<{label: string, value: string | number}>;
  visualization?: {
    type: string;
    config: {
      data?: any[];
      xKey?: string;
      yKey?: string;
      series?: Array<{ dataKey: string; name?: string; color?: string; type?: string }>;
      labels?: { title?: string; xAxis?: string; yAxis?: string };
      options?: Record<string, any>;
    };
  };
  // Add multiple visualizations support
  visualizations?: Array<{
    id: string;
    type: string;
    title: string;
    description?: string;
    config: {
      data?: any[];
      xKey?: string;
      yKey?: string;
      series?: Array<{ dataKey: string; name?: string; color?: string; type?: string }>;
      labels?: { title?: string; xAxis?: string; yAxis?: string };
      options?: Record<string, any>;
    };
  }>;
  recommendations?: string[];
  actionableInsights?: string[];
}

interface EnhancedStepByStepVisualizationProps {
  steps: AnalyticalStep[];
  autoPlay?: boolean;
  autoPlayDelay?: number;
  onComplete?: () => void;
  onStepChange?: (stepIndex: number) => void;
  initialStep?: number;
  dataSourceType?: string;
  insights?: string[];
  summary?: string;
  visualizationData?: {
    data: any[];
    type: string;
    xKey?: string;
    yKey?: string;
    series?: Array<{ dataKey: string; name?: string; color?: string; type?: string }>;
    title?: string;
    xAxisLabel?: string;
    yAxisLabel?: string;
    preserveType?: boolean;
    options?: {
      forceChartType?: string;
      isPieChart?: boolean;
      useDirectColorAssignment?: boolean;
      useMultipleColors?: boolean;
      [key: string]: any;
    };
  } | null;
  // Add support for multiple visualizations
  visualizationsData?: Array<{
    id: string;
    data: any[];
    type: string;
    xKey?: string;
    yKey?: string;
    series?: Array<{ dataKey: string; name?: string; color?: string; type?: string }>;
    title?: string;
    description?: string;
    xAxisLabel?: string;
    yAxisLabel?: string;
    preserveType?: boolean;
    options?: {
      forceChartType?: string;
      isPieChart?: boolean;
      useDirectColorAssignment?: boolean;
      useMultipleColors?: boolean;
      [key: string]: any;
    };
  }>;
  recommendations?: string[];
  actionableInsights?: string[];
}

// Define a context for steps data to be used by child components
interface StepContextType {
  dataSourceType: string;
  steps: AnalyticalStep[];
}

const StepContext = React.createContext<StepContextType | null>(null);

// Initialize DataProcessingService
const dataProcessingService = new DataProcessingService();

export const EnhancedStepByStepVisualization: React.FC<EnhancedStepByStepVisualizationProps> = ({
  steps: initialSteps = [],
  autoPlay = false,
  autoPlayDelay = 2000,
  onComplete,
  onStepChange,
  initialStep = 0,
  dataSourceType = 'unknown',
  insights = [],
  summary = '',
  visualizationData = null,
  visualizationsData = []
}) => {
  // State for steps
  const [steps, setSteps] = useState<AnalyticalStep[]>(initialSteps);
  const [expandedSteps, setExpandedSteps] = useState<string[]>([]);
  const [isReady, setIsReady] = useState(false);
  const [currentStepIndex, setCurrentStepIndex] = useState(initialStep);
  const [recommendations, setRecommendations] = useState<string[]>([]);
  // Current slide for visualization
  const [currentSlide, setCurrentSlide] = useState(0);
  // Local state for visualizations data
  const [localVisualizationsData, setLocalVisualizationsData] = useState<any[]>([]);
  // Show/hide data table toggle
  const [showDataTable, setShowDataTable] = useState(false);

  // Refs for tracking data to avoid duplicates
  const visualizationDataRef = useRef<string>('');
  const visualizationsDataRef = useRef<string>('');

  // Define a normalized data source type
  const normalizedDataSourceType = useMemo(() => {
    if (!dataSourceType) return 'unknown';
    
    // Map data source types to standardized format
    const sourceTypeMap: Record<string, string> = {
      'pdf': 'pdf',
      'excel': 'spreadsheet',
      'csv': 'spreadsheet',
      'doc': 'document',
      'docx': 'document',
      'database': 'database',
      'table': 'database',
      'sql': 'database',
      'api': 'api',
      'rest': 'api',
      'qdrant': 'qdrant',
      'vector_db': 'qdrant',
      'vector-db': 'qdrant',
      'vectordb': 'qdrant'
    };
    
    const normalizedType = dataSourceType.toLowerCase().replace(/[^a-z0-9_-]/g, '');
    return sourceTypeMap[normalizedType] || normalizedType || 'unknown';
  }, [dataSourceType]);
  
  console.log('Data source type received:', JSON.stringify(dataSourceType));
  console.log('Normalized data source type:', JSON.stringify(normalizedDataSourceType));
  
  // Completely disable mock data generation
  const generateSampleData = (): any[] => {
    // Always return an empty array - completely disable mock data
    return [];
  };
  
  // Force disable mock data completely and make it global
  useEffect(() => {
    // No need to set showMockData since we removed it
    
    // Define global variable to disable mock data across the application
    try {
      if (typeof window !== 'undefined') {
        (window as any).DISABLE_MOCK_DATA = true;
        (window as any).SHOW_TEMPLATES_DURING_THINKING = false;
      }
    } catch (e) {
      console.error('Failed to set global mock data flag:', e);
    }
  }, []);
  
  // Normalize data source type for consistent handling
  const normalizedDataSourceType = useMemo(() => {
    const type = (dataSourceType || '').toLowerCase();
    
    // Enhanced data source type detection with Qdrant prioritization
    if (type.includes('qdrant') || type.includes('vector') || type.includes('collection')) return 'qdrant';
    if (type.includes('pdf') || type.includes('document')) return 'pdf';
    if (type.includes('csv') || type.includes('excel') || type.includes('spreadsheet')) return 'excel';
    if (type.includes('database') || type.includes('sql')) return 'database';
    if (type.includes('local-files')) return 'qdrant'; // Treat local-files as Qdrant
    
    return type || 'qdrant'; // Default to Qdrant rather than unknown
  }, [dataSourceType]);
  
  // Log important props for debugging
  useEffect(() => {
    console.log('EnhancedStepByStepVisualization - Props received:', {
      stepsCount: initialSteps.length,
      dataSourceType,
      normalizedDataSourceType,
      hasInsights: insights.length > 0,
      hasSummary: !!summary,
      hasVisualizationData: !!visualizationData,
      multipleVisualizationsCount: visualizationsData?.length || 0
    });
    
    // Log more detailed information about the data source type
    console.log(`Data source type received: "${dataSourceType}"`);
    console.log(`Normalized data source type: "${normalizedDataSourceType}"`);
    
    if (normalizedDataSourceType === 'unknown' || normalizedDataSourceType === '') {
      console.warn('Non-specific data source type detected. This may affect RAG functionality.');
    }
    
    // Set ready state after a short delay to ensure all data is processed
    // Only set ready if we have actual data to display
    if (initialSteps.length > 0 || summary || visualizationData || (visualizationsData && visualizationsData.length > 0)) {
      const hasValidData = initialSteps.some(step => 
        step.content || 
        (step.visualization && step.visualization.config && step.visualization.config.data) ||
        (step.visualizations && step.visualizations.length > 0)
      );
      
      if (hasValidData || summary || visualizationData || (visualizationsData && visualizationsData.length > 0)) {
        // Set ready state after a short delay to ensure all data is processed
        const timer = setTimeout(() => {
          setIsReady(true);
        }, 100);
        return () => clearTimeout(timer);
      }
    }
  }, [initialSteps, dataSourceType, normalizedDataSourceType, insights, summary, visualizationData, visualizationsData]);
  
  // Create context value for steps
  const contextValue = useMemo<StepContextType>(() => ({
    dataSourceType: normalizedDataSourceType,
    steps
  }), [normalizedDataSourceType, steps]);
  
  // Add ref to track previous visualization data
  const visualizationDataRef = useRef<string | null>(null);
  
  // Track multiple visualizations
  const visualizationsDataRef = useRef<string | null>(null);
  
  // Add local state for visualizations data
  const [localVisualizationsData, setLocalVisualizationsData] = useState<any[]>([]);
  
  // Add current slide state for visualization navigation
  const [currentSlide, setCurrentSlide] = useState(0);
  const [showDataTable, setShowDataTable] = useState(false);
  
  // Update steps when initialSteps changes
  useEffect(() => {
    setSteps(initialSteps);
  }, [initialSteps]);
  
  // Create default steps if none are provided but summary is available
  useEffect(() => {
    if (initialSteps.length === 0 && summary && summary.length > 0) {
      console.log('Creating default step from summary content');
      
      // Create a simple default step without mock data
      const defaultSteps = [{
        id: 'default-step',
        type: 'info',
        description: 'Search Results',
        order: 1,
        content: summary,
        // Use empty data array - no mock data
        data: []
      }];
      
      setSteps(defaultSteps);
    }
  }, [initialSteps, summary]);
  
  // Add all visualizations from visualizationsData if provided
  useEffect(() => {
    if (visualizationsData && 
        visualizationsData.length > 0 && 
        visualizationsData.every(viz => viz.data && Array.isArray(viz.data) && viz.data.length > 0)) {
      
      // Check if this visualization data already exists in steps
      const dataString = JSON.stringify(visualizationsData);
      const prevDataString = visualizationsDataRef.current;
      
      // Only add new steps if the data has changed
      if (dataString !== prevDataString) {
        visualizationsDataRef.current = dataString;
        
        // Create new steps for each visualization
        const newSteps = visualizationsData.map((vizData, index) => {
          // Generate meaningful insights based on the data
          const dataInsights = generateInsightsFromData(
            vizData.data, 
            vizData.type,
            vizData.xKey,
            vizData.yKey
          );
          
          // Respect the requested chart type
          const chartType = vizData.options?.forceChartType || 
                           vizData.type || 
                           (vizData.options?.isPieChart ? 'pie' : 'bar');
                           
          return {
            id: `viz-${vizData.id || Date.now() + index}`,
            type: 'visualization',
            description: vizData.description || `${vizData.type.charAt(0).toUpperCase() + vizData.type.slice(1)} Analysis`,
            order: steps.length + index + 1,
            content: `## ${vizData.title || 'Data Analysis'}\n\n` +
                    `${vizData.description || 'This visualization shows patterns in the data.'}\n\n` +
                    '```json\n' + 
                    JSON.stringify(vizData.data, null, 2) + 
                    '\n```',
            insights: dataInsights,
            metrics: generateMetricsFromData(vizData.data),
            visualization: {
              type: chartType,
              config: {
                data: vizData.data,
                xKey: vizData.xKey || (vizData.data[0] ? Object.keys(vizData.data[0])[0] : undefined),
                yKey: vizData.yKey || (vizData.data[0] ? Object.keys(vizData.data[0])[1] : undefined),
                series: vizData.series || [
                  {
                    dataKey: vizData.yKey || (vizData.data[0] ? Object.keys(vizData.data[0])[1] : 'value'),
                    name: vizData.yAxisLabel || (vizData.data[0] ? Object.keys(vizData.data[0])[1] : 'Value')
                  }
                ],
                labels: {
                  title: vizData.title || 'Data Analysis',
                  xAxis: vizData.xAxisLabel || (vizData.data[0] ? Object.keys(vizData.data[0])[0] : 'Category'),
                  yAxis: vizData.yAxisLabel || (vizData.data[0] ? Object.keys(vizData.data[0])[1] : 'Value')
                },
                options: {
                  useDirectColorAssignment: true,
                  useMultipleColors: true,
                  theme: document.documentElement.classList.contains('dark') ? 'dark' : 'light',
                  ...vizData.options
                }
              }
            }
          };
        });
        
        // Add the new steps to existing steps
        setSteps(prevSteps => [...prevSteps, ...newSteps]);
        
        // Auto-expand the new steps
        for (const step of newSteps) {
          setExpandedSteps(prev => [...prev, step.id]);
        }
      }
    }
  }, [visualizationsData, steps]);
  
  // Add visualization step if visualizationData is provided
  useEffect(() => {
    if (visualizationData && 
        visualizationData.data && 
        Array.isArray(visualizationData.data) && 
        visualizationData.data.length > 0 && 
        visualizationData.type) {
      
      // Check if this visualization data already exists in steps
      const dataString = JSON.stringify(visualizationData.data);
      const prevDataString = visualizationDataRef.current;
      
      // Only add a new step if the data has changed
      if (dataString !== prevDataString) {
        visualizationDataRef.current = dataString;
        
        // Check if the step already exists
        const existingStep = steps.find(step => 
          step.visualization && 
          JSON.stringify(step.visualization.config.data) === dataString
        );
        
        if (!existingStep) {
          // Generate meaningful insights from the data
          const dataInsights = generateInsightsFromData(
            visualizationData.data, 
            visualizationData.type,
            visualizationData.xKey,
            visualizationData.yKey
          );
          
          // Respect the requested chart type
          const chartType = visualizationData.options?.forceChartType || 
                           visualizationData.type || 
                           (visualizationData.options?.isPieChart ? 'pie' : 'bar');
          
          // Create a new step with proper visualization
          const newStep: AnalyticalStep = {
            id: `viz-${Date.now()}`,
            type: 'visualization',
            description: `Data Analysis for ${visualizationData.title || 'Dataset'}`,
            order: steps.length + 1,
            content: `## ${visualizationData.title || 'Data Analysis'}\n\n` +
                    `This visualization reveals patterns and insights in the data.\n\n` +
                    '```json\n' + 
                    JSON.stringify(visualizationData.data, null, 2) + 
                    '\n```',
            insights: dataInsights,
            metrics: generateMetricsFromData(visualizationData.data),
            visualization: {
              type: chartType,
              config: {
                data: visualizationData.data,
                xKey: visualizationData.xKey || (visualizationData.data[0] ? Object.keys(visualizationData.data[0])[0] : undefined),
                yKey: visualizationData.yKey || (visualizationData.data[0] ? Object.keys(visualizationData.data[0])[1] : undefined),
                series: visualizationData.series || [
                  {
                    dataKey: visualizationData.yKey || (visualizationData.data[0] ? Object.keys(visualizationData.data[0])[1] : 'value'),
                    name: visualizationData.title || 'Value'
                  }
                ],
                labels: {
                  title: visualizationData.title || `Data Analysis`,
                  xAxis: visualizationData.xAxisLabel || (visualizationData.data[0] ? Object.keys(visualizationData.data[0])[0] : 'Category'),
                  yAxis: visualizationData.yAxisLabel || (visualizationData.data[0] ? Object.keys(visualizationData.data[0])[1] : 'Value')
                },
                options: {
                  useDirectColorAssignment: true,
                  useMultipleColors: true,
                  theme: document.documentElement.classList.contains('dark') ? 'dark' : 'light',
                  ...visualizationData.options
                }
              }
            }
          };
          
          // Add the new step to the steps array
          setSteps(prevSteps => [...prevSteps, newStep]);
          
          // Auto-expand the new step
          setExpandedSteps(prev => [...prev, newStep.id]);
        }
      }
    }
  }, [visualizationData, steps]);
  
  // Handle auto-advancing with useEffect
  useEffect(() => {
    // Only continue if autoplay is enabled and we're not at the end
    if (autoPlay && currentStepIndex < steps.length - 1) {
      const timer = setTimeout(() => {
        setCurrentStepIndex(prev => prev + 1);
      }, autoPlayDelay);
      
      return () => clearTimeout(timer);
    }
    
    // If we've reached the end, call onComplete
    if (currentStepIndex === steps.length - 1) {
      if (onComplete) {
        onComplete();
      }
    }
    
    // Notify about step change
    if (onStepChange) {
      onStepChange(currentStepIndex);
    }
  }, [currentStepIndex, steps.length, autoPlay, autoPlayDelay, onComplete, onStepChange]);
  
  // Toggle step expansion
  const toggleStepExpand = (stepId: string) => {
    setExpandedSteps(prev => 
      prev.includes(stepId) 
        ? prev.filter(id => id !== stepId) 
        : [...prev, stepId]
    );
  };

  // Helper function to safely render cell values
  const renderCellValue = (value: any): string => {
    if (value === null || value === undefined) return '';
    if (typeof value === 'object') return JSON.stringify(value);
    return String(value);
  };
  
  // Generate insights from data
  const generateMetricsFromData = (data: any[]): Array<{label: string, value: string | number}> => {
    if (!data || data.length === 0) return [];
    
    const metrics: Array<{label: string, value: string | number}> = [];
    try {
      // Basic metrics
      metrics.push({ label: 'Total Records', value: data.length });
      
      // If we have numerical data, calculate statistics
      const numericKeys = Object.keys(data[0]).filter(key => {
        return !isNaN(parseFloat(data[0][key]));
      });
      
      if (numericKeys.length > 0) {
        const key = numericKeys[0]; // Use first numeric key for statistics
        
        // Calculate sum, average, max, min
        const values = data.map(item => parseFloat(item[key])).filter(val => !isNaN(val));
        if (values.length > 0) {
          const sum = values.reduce((a, b) => a + b, 0);
          const avg = sum / values.length;
          const max = Math.max(...values);
          const min = Math.min(...values);
          
          metrics.push({ label: 'Total Sum', value: sum.toFixed(2) });
          metrics.push({ label: 'Average', value: avg.toFixed(2) });
          metrics.push({ label: 'Maximum', value: max });
          metrics.push({ label: 'Minimum', value: min });
        }
      }
      
      // Add data source specific metrics
      if (data[0].type) {
        // Count by type if available
        const typeCounts: Record<string, number> = {};
        data.forEach(item => {
          typeCounts[item.type] = (typeCounts[item.type] || 0) + 1;
        });
        
        const primaryType = Object.entries(typeCounts)
          .sort((a, b) => b[1] - a[1])
          .map(([type, count]) => ({ type, count }))[0];
          
        if (primaryType) {
          metrics.push({ 
            label: 'Primary Type', 
            value: `${primaryType.type} (${primaryType.count})` 
          });
        }
      }
      
    } catch (error) {
      console.error('Error generating metrics:', error);
    }
    
    return metrics;
  };
  
  // Add visualization to dashboard
  const handleAddToDashboard = useCallback(async (visualization: any, vizId: string) => {
    if (!visualization || !normalizedDataSourceType) return;

    try {
      console.log('Visualization data being sent to dashboard:', JSON.stringify(visualization, null, 2));
      
      // Set the current visualization as being added to dashboard
      setAddingToDashboard(vizId);
      
      // Create instance and call addToDashboard method
      const dataProcessingService = DataProcessingService.getInstance();
      const success = await dataProcessingService.addToDashboard(visualization);
      
      if (success) {
        showNotification({
          type: 'success',
          message: 'Visualization added to dashboard!'
        });
      } else {
        showNotification({
          type: 'error',
          message: 'Failed to add visualization to dashboard'
        });
      }
      
      // Clear the adding state
      setAddingToDashboard(null);
    } catch (error) {
      console.error('Error adding to dashboard:', error);
      showNotification({
        type: 'error',
        message: 'An error occurred while adding to dashboard'
      });
      
      // Clear the adding state on error
      setAddingToDashboard(null);
    }
  }, [normalizedDataSourceType, showNotification]);
  
  // Get appropriate icon for step type
  const getStepIcon = (type: string) => {
    switch (type.toLowerCase()) {
      case 'filtering':
        return <FilterIcon />;
      case 'aggregation':
        return <AggregateIcon />;
      case 'grouping':
        return <GroupIcon />;
      case 'sorting':
        return <SortIcon />;
      case 'visualization':
        return <ChartBarIcon />;
      case 'comparative':
        return <CompareIcon />;
      case 'insights':
        return <InsightIcon />;
      case 'table':
        return <TableIcon />;
      default:
        return <TableIcon />;
    }
  };
  
  // Get background color based on step type
  const getStepBgColor = (type: string) => {
    switch (type.toLowerCase()) {
      case 'filtering':
        return 'border-blue-300 bg-blue-50 dark:border-blue-700 dark:bg-blue-900/30';
      case 'aggregation':
        return 'border-indigo-300 bg-indigo-50 dark:border-indigo-700 dark:bg-indigo-900/30';
      case 'grouping':
        return 'border-purple-300 bg-purple-50 dark:border-purple-700 dark:bg-purple-900/30';
      case 'sorting':
        return 'border-green-300 bg-green-50 dark:border-green-700 dark:bg-green-900/30';
      case 'visualization':
        return 'border-yellow-300 bg-yellow-50 dark:border-yellow-700 dark:bg-yellow-900/30';
      case 'comparative':
        return 'border-orange-300 bg-orange-50 dark:border-orange-700 dark:bg-orange-900/30';
      case 'insights':
        return 'border-pink-300 bg-pink-50 dark:border-pink-700 dark:bg-pink-900/30';
      case 'table':
        return 'border-gray-300 bg-gray-50 dark:border-gray-700 dark:bg-gray-800';
      default:
        return 'border-gray-200 bg-white dark:border-gray-700 dark:bg-gray-800';
    }
  };
  
  // Enhanced function to extract and process step data from Qdrant
  const processStepData = (step: AnalyticalStep) => {
    if (!step.data && !step.content) {
      return { hasData: false, tableData: null as any[] | null, processed: step.content || '', tables: [] };
    }
    
    try {
      // Initialize an array to store extracted tables
      const tables: Array<{title: string, data: any[], content: string}> = [];
      
      // Get the processed content (use content if available, otherwise use description)
      let processed = step.content || step.description || '';
      
      // Check if content has actual table data structures (arrays of objects)
      let tableData: any[] | null = null;
      
      // Handle data directly from Qdrant if available
      if (step.data) {
        // If data is a string, try to parse it as JSON
        if (typeof step.data === 'string') {
          try {
            const parsedData = JSON.parse(step.data);
            if (Array.isArray(parsedData) && parsedData.length > 0) {
              tableData = parsedData;
            }
          } catch (e) {
            console.log('Data is not valid JSON, using as text', step.data);
            // If it's not valid JSON, append it to the processed content
            processed += '\n\n' + step.data;
          }
        } 
        // If data is an array, use it directly
        else if (Array.isArray(step.data)) {
          tableData = step.data;
        } 
        // If data is an object, convert to array with single item
        else if (typeof step.data === 'object' && step.data !== null) {
          tableData = [step.data];
        }
      }
      
      // Search for markdown tables in the content
      const markdownTables = TableFormatter.extractTablesFromMarkdown(processed);
      if (markdownTables && markdownTables.length > 0) {
        // If we found markdown tables and don't already have tableData, use the first one
        if (!tableData && markdownTables[0].length > 0) {
          tableData = markdownTables[0];
        }
        
        // Add all markdown tables to our tables array
        markdownTables.forEach((tableRows, index) => {
          if (tableRows.length > 0) {
            tables.push({
              title: `Table ${index + 1}`,
              data: tableRows,
              content: TableFormatter.toMarkdownTable(tableRows)
            });
          }
        });
      }
      
      return { 
        hasData: tableData !== null || tables.length > 0, 
        tableData, 
        processed, 
        tables 
      };
    } catch (e) {
      console.error('Error processing step data:', e);
      return { 
        hasData: false, 
        tableData: null, 
        processed: step.content || step.description || '', 
        tables: [] 
      };
    }
  };
  
  // Enhance the renderStep function to properly display tables
  // @ts-ignore - This function is currently unused but kept for future use
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const renderStep = useCallback((step: AnalyticalStep, index: number) => {
    const isExpanded = expandedSteps.includes(step.id);
    const stepIcon = getStepIcon(step.type);
    const stepBgColor = getStepBgColor(step.type);
    
    // Process the step data to extract tables and format content
    const { processed } = processStepData(step);
    
    // Format the step type to lowercase for display
    const displayType = step.type.toLowerCase();
    
    // Clean up the description text by removing all numbering, markdown, and type prefixes
    let cleanDescription = step.description
      .replace(/^\d+\.\s*/, '') // Remove leading numbers like "1. "
      .replace(/^\d+\.\s*\d+\.\s*/, '') // Remove double numbering like "1. 1. "
      .replace(/\*\*([^*]+)\*\*:?\s*/g, '') // Remove markdown bold patterns with colon like "**AGGREGATION:** "
      .replace(new RegExp(`^${step.type}:\\s*`, 'i'), '') // Remove type prefix like "TYPE: " (case insensitive)
      .replace(new RegExp(`^${displayType}:\\s*`, 'i'), '') // Remove lowercase type prefix
      .replace(new RegExp(`^${displayType.toUpperCase()}:\\s*`, 'i'), '') // Remove uppercase type
      .trim();
    
    // Remove any duplicate content between type and description
    if (cleanDescription.startsWith('First, I reviewed')) {
      // If it starts with a common pattern, ensure it's only shown once
      cleanDescription = cleanDescription.replace(/^\d+\.\s*/, ''); // Remove any remaining numbers
    }
    
    // Extract the original text from the processed content for the results section
    const originalText = processed || step.description;
    
    return (
      <motion.div 
        key={step.id}
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3, ease: "easeOut" }}
        className={`mb-6 border rounded-xl overflow-hidden bg-white dark:bg-gray-800/50 shadow-sm
                   ${isExpanded ? 'transition-all duration-500 ease-in-out' : 'hover:shadow-md transition-all'}`}
      >
        <div 
          className="px-5 py-4 flex justify-between items-center cursor-pointer"
          onClick={() => toggleStepExpand(step.id)}
        >
          <div className="flex items-center space-x-3">
            <div className={`p-2 rounded-lg ${stepBgColor} text-white flex items-center justify-center`}>
              {stepIcon}
            </div>
            <div>
              <div className="font-medium text-gray-900 dark:text-white">
                <span className="text-lg font-bold">{index + 1}.</span> <span className="text-purple-600 dark:text-purple-400 font-medium">{displayType}:</span> {cleanDescription}
              </div>
              {!isExpanded && (
                <div className="text-xs text-gray-500 dark:text-gray-400 max-w-[500px] truncate">
                  {processed?.substring(0, 100)}
                  {processed && processed.length > 100 ? '...' : ''}
                </div>
              )}
            </div>
          </div>
          <div>
            <button
              className="p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700"
              onClick={(e) => {
                e.stopPropagation();
                toggleStepExpand(step.id);
              }}
            >
              {isExpanded ? (
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-500 dark:text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 15l7-7 7 7" />
                </svg>
              ) : (
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-500 dark:text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                </svg>
              )}
            </button>
          </div>
        </div>
        
        {isExpanded && (
          <div className="px-5 pb-5 pt-3">
            <div>
              <div className="bg-gray-50 dark:bg-gray-800/50 rounded-lg border border-gray-200 dark:border-gray-700 p-4">
                <h3 className="text-md font-medium mb-3 text-gray-800 dark:text-gray-200">Analysis Details</h3>
                
                <p className="mb-4 text-sm text-gray-700 dark:text-gray-300">
                  This {displayType} analysis examines relationships and patterns in the data to extract meaningful business insights.
                </p>
                
                <div className="bg-purple-50 dark:bg-purple-900/20 p-3 rounded-lg border border-purple-100 dark:border-purple-800 mb-4">
                  <p className="text-sm text-purple-700 dark:text-purple-300">
                    <span className="font-medium">{displayType} Results:</span> {index + 1}. {originalText.includes("**") ? originalText : `**${step.type.toUpperCase()}:** ${cleanDescription}`}
                  </p>
                </div>
                
                <div className="mt-4">
                  <h4 className="text-sm font-medium text-gray-800 dark:text-gray-200 mb-2">Data Preview</h4>
                  <div className="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden">
                    <TableVisualization 
                      data={step.data && Array.isArray(step.data) && step.data.length > 0 ? step.data : generateSampleData()}
                      title=""
                      maxHeight="250px"
                      pagination={false}
                      pageSize={5}
                      responsive={true}
                      className="w-full"
                      style={{ fontSize: '0.875rem' }}
                    />
                  </div>
                </div>
              </div>
            </div>
          </div>
        )}
      </motion.div>
    );
  }, [expandedSteps, toggleStepExpand, getStepIcon, getStepBgColor, handleAddToDashboard]);
  
  // New function to render a visualization with proper chart type handling
  const renderVisualization = (vizConfig: any, height = 400) => {
    // Get the requested chart type from the configuration
    const requestedType = vizConfig.type || 'bar';
    
    // Check URL for forced chart type
    let finalChartType = requestedType;
    try {
      const urlParams = new URLSearchParams(window.location.search);
      const forcedChartType = urlParams.get('chartType');
      if (forcedChartType) {
        console.log(`[Visualization] Overriding chart type with URL parameter: ${forcedChartType}`);
        finalChartType = forcedChartType;
      }
    } catch (error) {
      console.error('Error checking URL parameters:', error);
    }
    
    // Respect specific options if provided
    if (vizConfig.options?.forceChartType) {
      finalChartType = vizConfig.options.forceChartType;
      console.log(`[Visualization] Using forced chart type from options: ${finalChartType}`);
    }
    
    // Apply the validated chart type
    const validatedType = validateVisualizationType(finalChartType);
    console.log(`[Visualization] Final chart type: ${validatedType} (requested: ${requestedType})`);
    
    // Define normalized chart types mapping
    const chartTypeMap: Record<string, string> = {
      'bar': 'bar',
      'column': 'bar',
      'stacked-bar': 'stackedBar',
      'stacked_bar': 'stackedBar',
      'horizontal-bar': 'horizontalBar',
      'horizontal_bar': 'horizontalBar',
      'line': 'line',
      'area': 'area',
      'enhanced-area': 'enhancedArea',
      'enhanced_area': 'enhancedArea',
      'pie': 'pie',
      'donut': 'donut',
      'doughnut': 'donut',
      'scatter': 'scatter',
      'radar': 'radar',
      'heatmap': 'heatmap',
      'funnel': 'funnel',
      'treemap': 'treemap',
      'sankey': 'sankey',
      'geospatial': 'geospatial',
      'network': 'network',
      'graph': 'network'
    };
    
    // Normalize the validated type
    const normalizedType = chartTypeMap[validatedType.toLowerCase()] || 'bar';
    
    // Create the visualization config with the correct chart type
    const config = {
      ...vizConfig,
      type: normalizedType,
      options: {
        ...(vizConfig.options || {}),
        theme: document.documentElement.classList.contains('dark') ? 'dark' : 'light',
        // Add appropriate options based on chart type
        ...(normalizedType === 'pie' || normalizedType === 'donut' ? {
          isPieChart: true,
          useDirectColorAssignment: true,
          useMultipleColors: true
        } : {})
      }
    };
    
    // Generate insights specifically for this visualization
    const vizInsights = vizConfig.data && Array.isArray(vizConfig.data) && vizConfig.data.length > 0 
      ? generateInsightsFromData(vizConfig.data, normalizedType, vizConfig.xKey, vizConfig.yKey).slice(0, 3)
      : [];
    
    // Use the ImportedVisualization component from the main Visualization module
    // This allows us to leverage the full range of chart types supported by the app
    return (
      <div className="slide-visualization">
        {/* Key insights at the top of the visualization */}
        {vizInsights.length > 0 && (
          <div className="key-insights-panel mb-4 bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg border border-blue-100 dark:border-blue-800/30">
            <h5 className="text-sm font-medium text-blue-800 dark:text-blue-300 mb-2 flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-4 h-4 mr-1">
                <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                <path fillRule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clipRule="evenodd" />
              </svg>
              Key Insights
            </h5>
            <ul className="space-y-1.5">
              {vizInsights.map((insight, idx) => (
                <li key={idx} className="flex items-start text-sm text-blue-700 dark:text-blue-200">
                  <span className="text-blue-500 dark:text-blue-400 mr-2 mt-0.5 font-bold">â€¢</span>
                  <span>{insight}</span>
                </li>
              ))}
            </ul>
          </div>
        )}
        
        {/* Chart visualization */}
        <div className="chart-container relative" style={{ height }}>
          <Suspense fallback={<VisualizationLoader />}>
            <LazyVisualizationWrapper
              config={config}
              height={height}
              width="100%"
              theme={document.documentElement.classList.contains('dark') ? 'dark' : 'light'}
            />
          </Suspense>
        </div>
      </div>
    );
  };

  // Generate domain-specific insights based on data type
  const generateDomainSpecificInsights = (data: any[], dataType: string): string[] => {
    if (!data || data.length === 0) return [];
    
    const insights: string[] = [];
    
    try {
      if (dataType === 'sales') {
        // Sales-specific insights
        insights.push(`Sales data analysis reveals patterns in performance across different segments and time periods.`);
        insights.push(`Consider analyzing year-over-year growth rates to identify long-term trends and seasonality effects.`);
        insights.push(`Examining regional distribution of sales could reveal untapped market opportunities.`);
      } else if (dataType === 'financial') {
        // Financial insights
        insights.push(`Financial data analysis can help identify cost-saving opportunities and revenue growth patterns.`);
        insights.push(`Quarter-over-quarter comparisons could highlight seasonal trends and annual growth patterns.`);
        insights.push(`Expense-to-revenue ratios may reveal operational efficiency opportunities.`);
      } else {
        // General insights
        insights.push(`Analysis of data patterns shows distribution characteristics worth exploring further.`);
        insights.push(`Consider segmenting this data to identify any hidden correlation patterns.`);
        insights.push(`Regular trend analysis could help identify seasonal or periodic variations.`);
      }
    } catch (error) {
      console.error('Error generating domain-specific insights:', error);
    }
    
    return insights;
  };
  
  // Generate more meaningful insights from data
  const generateInsightsFromData = (data: any[], type: string, xKey?: string, yKey?: string): string[] => {
    if (!data || data.length === 0) return [];
    
    const insights: string[] = [];
    try {
      // Use xKey and yKey if provided, otherwise use first two keys
      const actualXKey = xKey || Object.keys(data[0])[0];
      const actualYKey = yKey || Object.keys(data[0])[1];
      
      // Find max and min values
      const values = data.map(item => parseFloat(item[actualYKey])).filter(val => !isNaN(val));
      if (values.length > 0) {
        const maxValue = Math.max(...values);
        const minValue = Math.min(...values);
        const maxItem = data.find(item => parseFloat(item[actualYKey]) === maxValue);
        const minItem = data.find(item => parseFloat(item[actualYKey]) === minValue);
        const sum = values.reduce((a, b) => a + b, 0);
        const avg = sum / values.length;
        
        // Calculate standard deviation to measure variability
        const variance = values.reduce((v, value) => v + Math.pow(value - avg, 2), 0) / values.length;
        const stdDev = Math.sqrt(variance);
        const relativeStdDev = (stdDev / avg) * 100; // CV - coefficient of variation
        
        // Detailed insights about the data values
        if (maxItem) {
          insights.push(`The highest ${actualYKey} is ${maxValue.toFixed(2)} for ${maxItem[actualXKey]}, representing ${((maxValue / sum) * 100).toFixed(1)}% of the total.`);
        }
        
        if (minItem) {
          insights.push(`The lowest ${actualYKey} is ${minValue.toFixed(2)} for ${minItem[actualXKey]}, representing ${((minValue / sum) * 100).toFixed(1)}% of the total.`);
        }
        
        // Median analysis for distribution insights
        const sortedValues = [...values].sort((a, b) => a - b);
        const midIndex = Math.floor(sortedValues.length / 2);
        const median = sortedValues.length % 2 === 0 
          ? (sortedValues[midIndex - 1] + sortedValues[midIndex]) / 2 
          : sortedValues[midIndex];
        
        // Compare mean and median for distribution analysis
        const meanMedianDiff = ((avg - median) / avg) * 100;
        
        // Distribution insights based on standard deviation and mean-median comparison
        if (Math.abs(meanMedianDiff) > 20) {
          insights.push(`The distribution is skewed (mean: ${avg.toFixed(2)}, median: ${median.toFixed(2)}), suggesting outliers are affecting the average.`);
        } else if (relativeStdDev > 50) {
          insights.push(`The data shows high variability with a coefficient of variation of ${relativeStdDev.toFixed(1)}%, indicating diverse values.`);
        } else if (relativeStdDev < 10) {
          insights.push(`The data shows low variability with a coefficient of variation of ${relativeStdDev.toFixed(1)}%, indicating consistent values.`);
        } else {
          insights.push(`The data shows moderate variability with a coefficient of variation of ${relativeStdDev.toFixed(1)}%.`);
        }
        
        // Distribution insights
        const aboveAvg = values.filter(val => val > avg).length;
        const aboveAvgPercent = Math.round(aboveAvg / values.length * 100);
        insights.push(`${aboveAvg} items (${aboveAvgPercent}%) are above the average ${actualYKey} of ${avg.toFixed(2)}.`);
        
        // Distribution type insights
        if (aboveAvgPercent < 30) {
          insights.push(`The ${actualYKey} distribution is skewed, with a small number of high-value items dominating the total.`);
        } else if (aboveAvgPercent > 70) {
          insights.push(`The ${actualYKey} distribution is heavily weighted toward the high end, with most items having above-average values.`);
        } else {
          insights.push(`The ${actualYKey} distribution is relatively balanced, with a mix of high and low values.`);
        }
        
        // Concentration analysis
        const topThreeSum = values.sort((a, b) => b - a).slice(0, 3).reduce((a, b) => a + b, 0);
        const topThreePercent = (topThreeSum / sum) * 100;
        if (values.length > 3) {
          insights.push(`The top 3 items represent ${topThreePercent.toFixed(1)}% of the total ${actualYKey}, indicating a ${topThreePercent > 70 ? 'highly concentrated' : topThreePercent > 50 ? 'moderately concentrated' : 'diversified'} distribution.`);
        }
        
        // Pattern analysis based on chart type
        if (type === 'line' || type === 'area') {
          // Check for trend patterns in sequential data
          let increasingCount = 0;
          let decreasingCount = 0;
          
          for (let i = 1; i < values.length; i++) {
            if (values[i] > values[i-1]) increasingCount++;
            else if (values[i] < values[i-1]) decreasingCount++;
          }
          
          const trendPercentage = Math.max(increasingCount, decreasingCount) / (values.length - 1) * 100;
          
          if (trendPercentage > 70) {
            if (increasingCount > decreasingCount) {
              insights.push(`The data shows a clear upward trend, with ${trendPercentage.toFixed(0)}% of sequential points increasing.`);
            } else {
              insights.push(`The data shows a clear downward trend, with ${trendPercentage.toFixed(0)}% of sequential points decreasing.`);
            }
          } else if (trendPercentage > 50) {
            if (increasingCount > decreasingCount) {
              insights.push(`The data shows a moderate upward trend, with some fluctuations.`);
            } else {
              insights.push(`The data shows a moderate downward trend, with some fluctuations.`);
            }
          } else {
            insights.push(`The data shows significant fluctuations without a clear directional trend.`);
          }
        } else if (type === 'pie' || type === 'donut') {
          // Dominance analysis for pie charts
          const topCategory = maxItem ? maxItem[actualXKey] : '';
          const topValue = maxValue;
          const topPercent = (topValue / sum) * 100;
          
          if (topPercent > 50) {
            insights.push(`${topCategory} dominates the distribution with ${topPercent.toFixed(1)}% of the total, more than all other categories combined.`);
          } else if (topPercent > 33) {
            insights.push(`${topCategory} is the leading category with ${topPercent.toFixed(1)}% of the total, showing significant prominence.`);
          } else if (data.length > 3) {
            insights.push(`The distribution is relatively fragmented across ${data.length} categories, with no single category having an overwhelming majority.`);
          }
          
          // Analyze even distribution
          const idealPerCategory = 100 / data.length;
          const deviation = values.reduce((sum, val) => sum + Math.abs((val / sum * 100) - idealPerCategory), 0) / data.length;
          
          if (deviation < 5) {
            insights.push(`The distribution is remarkably even across all categories, with minimal variation from the expected even distribution.`);
          } else if (deviation > 20) {
            insights.push(`The distribution shows significant imbalance across categories, deviating ${deviation.toFixed(1)}% from an even distribution.`);
          }
        } else if (type === 'bar' || type === 'column') {
          // Quartile analysis for bar charts
          const q1Index = Math.floor(sortedValues.length / 4);
          const q3Index = Math.floor(3 * sortedValues.length / 4);
          const q1 = sortedValues[q1Index];
          const q3 = sortedValues[q3Index];
          const iqr = q3 - q1;
          
          // Check for outliers
          const outlierThresholdLow = q1 - 1.5 * iqr;
          const outlierThresholdHigh = q3 + 1.5 * iqr;
          const outliers = values.filter(v => v < outlierThresholdLow || v > outlierThresholdHigh);
          
          if (outliers.length > 0) {
            const outlierPercent = (outliers.length / values.length) * 100;
            insights.push(`${outliers.length} data points (${outlierPercent.toFixed(1)}%) are statistical outliers, falling outside the expected range.`);
          }
          
          // Check for bimodal distribution
          const binSize = (maxValue - minValue) / 5; // 5 bins for analysis
          const bins = Array(5).fill(0);
          
          values.forEach(v => {
            const binIndex = Math.min(4, Math.floor((v - minValue) / binSize));
            bins[binIndex]++;
          });
          
          // Check if there are two distinct peaks
          const maxBin = Math.max(...bins);
          const maxBinIndex = bins.indexOf(maxBin);
          bins[maxBinIndex] = 0; // Remove the tallest peak
          const secondMaxBin = Math.max(...bins);
          const secondMaxBinIndex = bins.indexOf(secondMaxBin);
          
          if (secondMaxBin > values.length * 0.2 && Math.abs(secondMaxBinIndex - maxBinIndex) >= 2) {
            insights.push(`The data distribution appears bimodal, with two distinct peaks suggesting two different groups or patterns.`);
          }
        }
      }
    } catch (error) {
      console.error('Error generating insights:', error);
      insights.push(`Analysis of ${data.length} data points shows patterns worth exploring.`);
    }
    
    return insights;
  };
  
  // Generate recommendations based on data
  const generateRecommendations = (type: string): string[] => {
    const recommendations: string[] = [];
    
    try {
      // General recommendations applicable to all data types
      recommendations.push('Consider segmenting the data further to identify hidden patterns and correlations.');
      recommendations.push('Analyze trends over time to identify seasonal patterns or long-term changes.');
      
      // Recommendations based on chart type
      if (type === 'pie' || type === 'donut') {
        recommendations.push('Combine categories below 5% into an "Other" category to improve chart readability.');
        recommendations.push('Consider switching to a bar chart if you have more than 7 categories for better visual comparison.');
        recommendations.push('Sort categories by value to highlight the relative importance of each segment.');
      } else if (type === 'bar' || type === 'column') {
        recommendations.push('Sort bars by value rather than category for easier identification of highest and lowest values.');
        recommendations.push('Use horizontal bars if you have many categories or long category names.');
        recommendations.push('Consider adding benchmark lines or thresholds to evaluate performance against targets.');
      } else if (type === 'line') {
        recommendations.push('Add trend lines or moving averages to smooth out fluctuations and reveal underlying patterns.');
        recommendations.push('Annotate significant data points to highlight key events or changes.');
        recommendations.push('Consider using dual axes for comparing metrics with different scales.');
      } else if (type === 'scatter') {
        recommendations.push('Add trendlines to visualize correlations between data points.');
        recommendations.push('Use color coding or size variations to add additional dimensions to your analysis.');
        recommendations.push('Consider clustering analysis to identify groups of similar data points.');
      } else if (type === 'heatmap') {
        recommendations.push('Adjust color scales to highlight specific ranges of values.');
        recommendations.push('Add annotations to explain particularly high or low values in the matrix.');
        recommendations.push('Consider hierarchical clustering to group similar rows and columns.');
      } else if (type === 'funnel' || type === 'treemap') {
        recommendations.push('Add percentage labels to highlight conversion rates between stages.');
        recommendations.push('Use consistent color coding to group related categories.');
        recommendations.push('Consider adding interactive tooltips to display detailed information for each segment.');
      }
      
      // Add data analysis recommendations
      recommendations.push('Examine outliers to understand exceptional cases that may provide valuable insights.');
      recommendations.push('Compare current data with historical benchmarks to identify significant changes or trends.');
      recommendations.push('Use statistical tests to validate whether observed patterns are statistically significant.');
      
      // Action-oriented recommendations
      recommendations.push('Create a dashboard with multiple visualizations to provide a comprehensive view of the data.');
      recommendations.push('Set up alerts for significant changes or anomalies in key metrics.');
      recommendations.push('Schedule regular data reviews to track changes over time and adjust strategies accordingly.');
    } catch (error) {
      console.error('Error generating recommendations:', error);
      recommendations.push('Analyze the data further to identify actionable insights and patterns.');
    }
    
    // Return a subset of recommendations to avoid overwhelming the user
    return recommendations.slice(0, 5);
  };
  
  // Generate a meaningful summary from the data
  const generateSummaryFromData = (data: any[]): string => {
    if (!data || data.length === 0) {
      return 'No data available for analysis.';
    }
    
    try {
      // Extract keys for analysis
      const keys = Object.keys(data[0]);
      const categories = data.map(item => item[keys[0]]);
      const valuesKey = keys[1] || 'value';
      const values = data.map(item => parseFloat(item[valuesKey])).filter(val => !isNaN(val));
      
      if (values.length === 0) {
        return `The dataset contains ${data.length} records, but no valid numerical values were found for analysis.`;
      }
      
      // Calculate basic statistics
      const sum = values.reduce((a, b) => a + b, 0);
      const avg = sum / values.length;
      const max = Math.max(...values);
      const min = Math.min(...values);
      const range = max - min;
      
      // Calculate standard deviation
      const variance = values.reduce((v, value) => v + Math.pow(value - avg, 2), 0) / values.length;
      const stdDev = Math.sqrt(variance);
      
      // Sort values to find median and quartiles
      const sortedValues = [...values].sort((a, b) => a - b);
      const midIndex = Math.floor(sortedValues.length / 2);
      const median = sortedValues.length % 2 === 0 
        ? (sortedValues[midIndex - 1] + sortedValues[midIndex]) / 2 
        : sortedValues[midIndex];
      
      // Find most frequent categories (top 3)
      const categoryFrequency: Record<string, number> = {};
      categories.forEach(cat => {
        categoryFrequency[cat] = (categoryFrequency[cat] || 0) + 1;
      });
      
      const sortedCategories = Object.entries(categoryFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(entry => entry[0]);
      
      // Identify distribution type
      let distributionType = '';
      if (Math.abs((avg - median) / avg) > 0.2) {
        // If mean and median differ significantly, distribution is skewed
        distributionType = avg > median 
          ? 'a right-skewed (positively skewed) distribution'
          : 'a left-skewed (negatively skewed) distribution';
      } else if (stdDev / avg < 0.1) {
        distributionType = 'a uniform distribution with low variance';
      } else if (stdDev / avg > 0.5) {
        distributionType = 'a highly variable distribution';
      } else {
        distributionType = 'a relatively normal distribution';
      }
      
      // Build a comprehensive summary
      let summary = `Analysis of ${data.length} data points reveals ${distributionType}`;
      
      // Add details based on data size
      if (data.length > 10) {
        summary += ` across ${categories.length} unique categories`;
      }
      
      summary += '.';
      
      // Add statistical insights
      summary += ` The average ${valuesKey} is ${avg.toFixed(2)} (median: ${median.toFixed(2)})`;
      
      if (data.length > 3) {
        summary += `, ranging from ${min.toFixed(2)} to ${max.toFixed(2)}`;
      }
      
      summary += '.';
      
      // Add insights about the spread and distribution
      if (data.length > 5) {
        const cvPercent = (stdDev / avg) * 100;
        summary += ` The coefficient of variation is ${cvPercent.toFixed(1)}%,`;
        
        if (cvPercent < 10) {
          summary += ' indicating highly consistent values with minimal variation.';
        } else if (cvPercent < 30) {
          summary += ' showing moderate variation between data points.';
        } else {
          summary += ' revealing substantial variation across the dataset.';
        }
      }
      
      // Add insight about most prominent categories
      if (sortedCategories.length > 0 && data.length > 3) {
        if (sortedCategories.length === 1) {
          summary += ` The only category present is "${sortedCategories[0]}".`;
        } else {
          const categoryList = sortedCategories
            .slice(0, Math.min(3, sortedCategories.length))
            .map(cat => `"${cat}"`)
            .join(', ');
          
          summary += ` The most frequently occurring categories are ${categoryList}.`;
        }
      }
      
      return summary;
    } catch (error) {
      console.error('Error generating data summary:', error);
      return `Analysis of ${data.length} data points reveals patterns worth exploring in more detail.`;
    }
  };
  
  // Function to generate multiple visualizations from the same dataset
  const generateMultipleVisualizations = (data: any[]): any[] => {
    if (!data || data.length === 0) return [];
    
    const visualizations = [];
    
    try {
      // Create normalized data where all rows have same structure
      const keys = Object.keys(data[0]);
      const xKey = keys[0];
      const yKey = keys[1] || keys[0];
      
      // Make sure data is properly formatted
      const normalizedData = data.map(item => {
        if (typeof item !== 'object' || item === null) {
          return { category: 'Unknown', value: 0 };
        }
        
        return { 
          category: item[xKey] || 'Unknown', 
          value: typeof item[yKey] === 'number' ? item[yKey] : parseFloat(item[yKey]) || 0
        };
      });
      
      console.log('Generating multiple visualizations from data:', normalizedData);
      
      // Bar chart - always include for categorical data
      visualizations.push({
        id: 'data-distribution-bar',
        title: 'Data Distribution by Category',
        description: 'Distribution of values across categories',
        type: 'bar',
        data: data, // Use original data format
        xKey: xKey,
        yKey: yKey,
        series: [{ dataKey: yKey, name: 'Value' }],
        xAxisLabel: 'Category',
        yAxisLabel: 'Value',
        options: {
          forceChartType: 'bar'
        }
      });
      
      // Pie chart - good for showing proportions
      visualizations.push({
        id: 'data-distribution-pie',
        title: 'Proportional Distribution',
        description: 'Proportional representation of each category',
        type: 'pie',
        data: data, // Use original data format
        xKey: xKey,
        yKey: yKey,
        series: [{ dataKey: yKey, name: 'Value' }],
        options: {
          forceChartType: 'pie',
          isPieChart: true,
          useMultipleColors: true
        }
      });
      
      // Line chart - for trend visualization
      visualizations.push({
        id: 'data-trend-line',
        title: 'Value Trend Analysis',
        description: 'Trend analysis showing patterns across categories',
        type: 'line',
        data: data, // Use original data format
        xKey: xKey,
        yKey: yKey,
        series: [{ dataKey: yKey, name: 'Value' }],
        xAxisLabel: 'Category',
        yAxisLabel: 'Value',
        options: {
          forceChartType: 'line'
        }
      });
      
      // If there are enough data points, add a treemap
      if (data.length >= 3) {
        visualizations.push({
          id: 'data-treemap',
          title: 'Hierarchical Value Distribution',
          description: 'Treemap showing the relative size of each category',
          type: 'treemap',
          data: data, // Use original data format
          xKey: xKey,
          yKey: yKey, 
          options: {
            forceChartType: 'treemap'
          }
        });
      }
    } catch (error) {
      console.error('Error generating multiple visualizations:', error);
    }
    
    return visualizations;
  };
  
  // Add visualization step if visualizationData is provided
  useEffect(() => {
    if (visualizationData && 
        visualizationData.data && 
        Array.isArray(visualizationData.data) && 
        visualizationData.data.length > 0 && 
        visualizationData.type) {
      
      // Check if this visualization data already exists in steps
      const dataString = JSON.stringify(visualizationData.data);
      const prevDataString = visualizationDataRef.current;
      
      // Only add a new step if the data has changed
      if (dataString !== prevDataString) {
        visualizationDataRef.current = dataString;
        
        // Check if the step already exists
        const existingStep = steps.find(step => 
          step.visualization && 
          JSON.stringify(step.visualization.config.data) === dataString
        );
        
        if (!existingStep) {
          // Generate multiple visualizations from the data
          const multipleVizs = generateMultipleVisualizations(visualizationData.data);
          
          // Set the multiple visualizations data directly
          // This is important to ensure the visualizationsData is available for rendering
          if (multipleVizs && multipleVizs.length > 0) {
            console.log(`Generated ${multipleVizs.length} visualizations:`, multipleVizs);
          }
          
          // Generate meaningful insights from the data
          const dataInsights = generateInsightsFromData(
            visualizationData.data, 
            visualizationData.type,
            visualizationData.xKey,
            visualizationData.yKey
          );
          
          // Generate recommendations
          const dataRecommendations = generateRecommendations(visualizationData.type);
          
          // Generate detailed summary
          const dataSummary = generateSummaryFromData(visualizationData.data);
          
          // Respect the requested chart type
          const chartType = visualizationData.options?.forceChartType || 
                           visualizationData.type || 
                           (visualizationData.options?.isPieChart ? 'pie' : 'bar');
          
          // Create a new step with proper visualization
          const newStep: AnalyticalStep = {
            id: `viz-${Date.now()}`,
            type: 'visualization',
            description: `Comprehensive Analysis of ${visualizationData.title || 'Dataset'}`,
            order: steps.length + 1,
            content: `## ${visualizationData.title || 'Data Analysis'}\n\n` +
                    `${dataSummary}\n\n` +
                    '```json\n' + 
                    JSON.stringify(visualizationData.data, null, 2) + 
                    '\n```',
            insights: dataInsights,
            recommendations: dataRecommendations,
            metrics: generateMetricsFromData(visualizationData.data),
            visualization: {
              type: chartType,
              config: {
                data: visualizationData.data,
                xKey: visualizationData.xKey || (visualizationData.data[0] ? Object.keys(visualizationData.data[0])[0] : undefined),
                yKey: visualizationData.yKey || (visualizationData.data[0] ? Object.keys(visualizationData.data[0])[1] : undefined),
                series: visualizationData.series || [
                  {
                    dataKey: visualizationData.yKey || (visualizationData.data[0] ? Object.keys(visualizationData.data[0])[1] : 'value'),
                    name: visualizationData.title || 'Value'
                  }
                ],
                labels: {
                  title: visualizationData.title || `Data Analysis`,
                  xAxis: visualizationData.xAxisLabel || (visualizationData.data[0] ? Object.keys(visualizationData.data[0])[0] : 'Category'),
                  yAxis: visualizationData.yAxisLabel || (visualizationData.data[0] ? Object.keys(visualizationData.data[0])[1] : 'Value')
                },
                options: {
                  useDirectColorAssignment: true,
                  useMultipleColors: true,
                  theme: document.documentElement.classList.contains('dark') ? 'dark' : 'light',
                  ...visualizationData.options
                }
              }
            }
          };
          
          // Add the new step to the steps array
          setSteps(prevSteps => [...prevSteps, newStep]);
          
          // Auto-expand the new step
          setExpandedSteps(prev => [...prev, newStep.id]);
        }
      }
    }
  }, [visualizationData, steps]);
  
  // New effect to handle visualizationsData property directly
  // This ensures multiple visualization slides are rendered
  useEffect(() => {
    if (visualizationsData && 
        Array.isArray(visualizationsData) && 
        visualizationsData.length > 0) {
      
      // Check if the visualizations data has changed
      const dataString = JSON.stringify(visualizationsData);
      const prevDataString = visualizationsDataRef.current;
      
      if (dataString !== prevDataString) {
        visualizationsDataRef.current = dataString;
        console.log(`Processing ${visualizationsData.length} visualizations directly from props`);
      }
    }
  }, [visualizationsData]);
  
  // Make sure initial data for visualizationsData
  useEffect(() => {
    // If we have a single visualization but no multiple visualizations,
    // generate multiple visualizations from the single one
    if (visualizationData && 
        visualizationData.data && 
        Array.isArray(visualizationData.data) && 
        visualizationData.data.length > 0 &&
        (!visualizationsData || visualizationsData.length === 0)) {
      
      // Generate multiple visualizations from visualizationData
      const multipleVizs = generateMultipleVisualizations(visualizationData.data);
      console.log(`Generated ${multipleVizs.length} visualizations from single visualization data`);
      
      // This will directly modify the DOM to update the visualizationsData array
      if (multipleVizs && multipleVizs.length > 0) {
        // Create a custom event to trigger the visualization update
        const vizEvent = new CustomEvent('multipleVisualizationsGenerated', { 
          detail: { visualizations: multipleVizs }
        });
        window.dispatchEvent(vizEvent);
        
        // Also log to console for debugging
        console.log('Multiple visualizations ready for rendering', multipleVizs);
      }
    }
  }, [visualizationData, visualizationsData]);

  // Function to generate a new chart type from existing data
  const generateAlternateChartType = useCallback((data: any[], currentType: string) => {
    if (!data || data.length === 0) return null;
    
    // Choose a different chart type than the current one
    const chartTypes = ['bar', 'pie', 'line', 'area', 'treemap'];
    const filteredTypes = chartTypes.filter(type => type !== currentType);
    const randomType = filteredTypes[Math.floor(Math.random() * filteredTypes.length)];
    
    const keys = Object.keys(data[0]);
    return {
      id: `alt-chart-${Date.now()}`,
      title: `Alternative ${randomType.charAt(0).toUpperCase() + randomType.slice(1)} View`,
      description: `${randomType.charAt(0).toUpperCase() + randomType.slice(1)} chart visualization of the same data`,
      type: randomType,
      data: data,
      xKey: keys[0],
      yKey: keys[1] || 'value',
      options: {
        forceChartType: randomType,
        useMultipleColors: true
      }
    };
  }, []);

  // Add listener for the custom event to update visualizationsData
  useEffect(() => {
    const handleVisualizationsGenerated = (event: any) => {
      const generatedVisualizations = event.detail?.visualizations;
      if (generatedVisualizations && Array.isArray(generatedVisualizations)) {
        console.log(`Received ${generatedVisualizations.length} visualizations from event`);
        
        // Update component state with the new visualizations
        if (visualizationData && visualizationData.data) {
          // Add an alternative chart type to increase diversity
          const alternateViz = generateAlternateChartType(
            visualizationData.data, 
            visualizationData.type || 'bar'
          );
          
          // Combine with the generated visualizations
          const combinedVisualizations = [...generatedVisualizations];
          if (alternateViz) {
            combinedVisualizations.push(alternateViz);
          }
          
          // Force an update to the DOM
          console.log('Setting multiple visualizations for rendering', combinedVisualizations);
          visualizationsDataRef.current = JSON.stringify(combinedVisualizations);
          
          // Force a component re-render
          // This will trigger the rendering of the visualization slides
          setIsReady(prev => !prev);
          setTimeout(() => setIsReady(prev => !prev), 50);
        }
      }
    };
    
    window.addEventListener('multipleVisualizationsGenerated', handleVisualizationsGenerated);
    return () => {
      window.removeEventListener('multipleVisualizationsGenerated', handleVisualizationsGenerated);
    };
  }, [visualizationData, generateAlternateChartType]);
  
  // If no steps, show placeholder
  if ((!steps || steps.length === 0) && insights.length === 0 && !summary && !visualizationData && (!visualizationsData || visualizationsData.length === 0)) {
    return (
      <div className="rag-response-container">
        <div className="text-center text-gray-500 dark:text-gray-400 p-4">
          No visualization data available
        </div>
      </div>
    );
  }
  
  // Render a loading placeholder if not ready
  const renderLoadingPlaceholder = () => {
    return (
      <div className="p-4 bg-white dark:bg-gray-800 rounded-lg animate-pulse">
        <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/4 mb-4"></div>
        <div className="space-y-2">
          <div className="h-3 bg-gray-200 dark:bg-gray-700 rounded"></div>
          <div className="h-3 bg-gray-200 dark:bg-gray-700 rounded"></div>
          <div className="h-3 bg-gray-200 dark:bg-gray-700 rounded"></div>
        </div>
      </div>
    );
  };

  // Check if we should render content or loading placeholder
  const shouldRenderContent = isReady || initialSteps.length > 0 || summary || visualizationData || (visualizationsData && visualizationsData.length > 0);

  // Return the appropriate content
  if (!shouldRenderContent) {
    return renderLoadingPlaceholder();
  }
  
  // Function to handle visualization slides navigation
  const navigateSlide = (direction: 'next' | 'prev' | number) => {
    if (!localVisualizationsData || localVisualizationsData.length === 0) return;
    
    if (typeof direction === 'number') {
      // Direct navigation to a specific slide
      if (direction >= 0 && direction < localVisualizationsData.length) {
        setCurrentSlide(direction);
      }
    } else if (direction === 'next') {
      setCurrentSlide(current => (current + 1) % localVisualizationsData.length);
    } else {
      setCurrentSlide(current => (current - 1 + localVisualizationsData.length) % localVisualizationsData.length);
    }
  };
  
  // Render visualization slides section if available
  const renderVisualizationSlides = () => {
    if (!localVisualizationsData || localVisualizationsData.length === 0) {
      return null;
    }
    
    // Get current visualization
    const currentViz = localVisualizationsData[currentSlide];
    if (!currentViz) return null;
    
    return (
      <div className="section mb-6">
        <h3 className="text-lg font-semibold mb-3 text-gray-800 dark:text-gray-100 flex items-center justify-between">
          <div className="flex items-center">
            <span className="bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300 w-7 h-7 rounded-full flex items-center justify-center mr-2 text-sm">
              3
            </span>
            <span>Visualizations</span>
            <span className="ml-2 text-sm text-gray-500 dark:text-gray-400">
              ({currentSlide + 1} of {localVisualizationsData.length})
            </span>
          </div>
          
          {/* Navigation controls */}
          <div className="flex items-center space-x-2">
            <button 
              onClick={() => navigateSlide('prev')}
              className="p-1 rounded-full bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition"
              aria-label="Previous visualization"
              disabled={localVisualizationsData.length <= 1}
            >
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-5 h-5">
                <path fillRule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clipRule="evenodd" />
              </svg>
            </button>
            <button 
              onClick={() => navigateSlide('next')}
              className="p-1 rounded-full bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition"
              aria-label="Next visualization"
              disabled={localVisualizationsData.length <= 1}
            >
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-5 h-5">
                <path fillRule="evenodd" d="M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z" clipRule="evenodd" />
              </svg>
            </button>
          </div>
        </h3>
        
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-100 dark:border-gray-700/80 p-5 backdrop-blur-sm">
          {/* Slide header */}
          <div className="mb-4">
            <h4 className="text-base font-medium text-gray-900 dark:text-gray-100">{currentViz.title}</h4>
            {currentViz.description && (
              <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">{currentViz.description}</p>
            )}
          </div>
          
          {/* Visualization with insights */}
          <div className="mb-4">
            {renderVisualization(currentViz)}
          </div>
          
          {/* Slide indicator dots */}
          {localVisualizationsData.length > 1 && (
            <div className="flex justify-center mt-4 space-x-2">
              {localVisualizationsData.map((_, index) => (
                <button
                  key={index}
                  onClick={() => navigateSlide(index)}
                  className={`w-2 h-2 rounded-full ${
                    index === currentSlide 
                      ? 'bg-blue-600 dark:bg-blue-400' 
                      : 'bg-gray-300 dark:bg-gray-600 hover:bg-gray-400 dark:hover:bg-gray-500'
                  }`}
                  aria-label={`Go to slide ${index + 1}`}
                />
              ))}
            </div>
          )}
          
          {/* Data table toggle */}
          <div className="mt-4 border-t border-gray-100 dark:border-gray-700 pt-4">
            <button
              onClick={() => setShowDataTable(!showDataTable)}
              className="flex items-center text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100"
            >
              {showDataTable ? (
                <>
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-4 h-4 mr-1">
                    <path fillRule="evenodd" d="M14.77 12.79a.75.75 0 01-1.06-.02L10 8.832 6.29 12.77a.75.75 0 11-1.08-1.04l4.25-4.5a.75.75 0 011.08 0l4.25 4.5a.75.75 0 01-.02 1.06z" clipRule="evenodd" />
                  </svg>
                  Hide Data Source
                </>
              ) : (
                <>
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-4 h-4 mr-1">
                    <path fillRule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clipRule="evenodd" />
                  </svg>
                  View Data Source
                </>
              )}
            </button>
            
            {/* Data table */}
            {showDataTable && currentViz.data && Array.isArray(currentViz.data) && (
              <div className="mt-3 overflow-x-auto text-xs">
                <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                  <thead className="bg-gray-50 dark:bg-gray-800">
                    <tr>
                      {Object.keys(currentViz.data[0]).map(key => (
                        <th key={key} className="px-3 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                          {key}
                        </th>
                      ))}
                    </tr>
                  </thead>
                  <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                    {currentViz.data.slice(0, 5).map((item, index) => (
                      <tr key={index} className={index % 2 === 0 ? 'bg-white dark:bg-gray-800' : 'bg-gray-50 dark:bg-gray-700/30'}>
                        {Object.keys(currentViz.data[0]).map(key => (
                          <td key={`${index}-${key}`} className="px-3 py-2 whitespace-nowrap text-gray-700 dark:text-gray-300">
                            {typeof item[key] === 'number' ? item[key].toLocaleString() : String(item[key])}
                          </td>
                        ))}
                      </tr>
                    ))}
                  </tbody>
                </table>
                {currentViz.data.length > 5 && (
                  <div className="text-center py-2 text-xs text-gray-500 dark:text-gray-400">
                    Showing 5 of {currentViz.data.length} rows
                  </div>
                )}
              </div>
            )}
          </div>
          
          {/* Actions footer */}
          <div className="mt-4 border-t border-gray-100 dark:border-gray-700 pt-4 flex justify-end">
            <button
              onClick={() => {
                // Format visualization data for dashboard
                const visualization = {
                  title: currentViz.title,
                  type: currentViz.type,
                  data: currentViz.data,
                  config: {
                    xAxis: currentViz.xKey,
                    yAxis: currentViz.yKey,
                    chartType: currentViz.type,
                    ...currentViz.options
                  }
                };
                // Add to dashboard
                dataProcessingService.addToDashboard(visualization);
              }}
              className="flex items-center text-xs px-3 py-1.5 bg-blue-50 text-blue-600 dark:bg-blue-900/20 dark:text-blue-400 rounded hover:bg-blue-100 dark:hover:bg-blue-800/30"
            >
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-3.5 h-3.5 mr-1">
                <path d="M10.75 4.75a.75.75 0 00-1.5 0v4.5h-4.5a.75.75 0 000 1.5h4.5v4.5a.75.75 0 001.5 0v-4.5h4.5a.75.75 0 000-1.5h-4.5v-4.5z" />
              </svg>
              Add to Dashboard
            </button>
          </div>
        </div>
      </div>
    );
  };
  
  return (
    <StepContext.Provider value={contextValue}>
      <div className={`step-by-step-visualization ${expandedSteps.length === steps.length ? 'is-complete' : ''}`}>
        {/* No data message */}
        {initialSteps.length === 0 && !summary && !visualizationData && (!visualizationsData || visualizationsData.length === 0) && (
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6 mb-6">
            <div className="flex flex-col items-center justify-center text-center">
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-12 h-12 text-gray-400 mb-4">
                <path strokeLinecap="round" strokeLinejoin="round" d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z" />
              </svg>
              <h3 className="text-lg font-semibold mb-2 text-gray-800 dark:text-gray-200">No Data Found</h3>
              <p className="text-gray-600 dark:text-gray-400 mb-4">
                No relevant data was found for your query in the selected {normalizedDataSourceType || 'data source'}. 
                Please try a different query or select another data source.
              </p>
              <div className="flex flex-col space-y-3">
                <div className="text-sm text-gray-500 dark:text-gray-400 mb-2">
                  <strong>Troubleshooting tips:</strong>
                  <ul className="list-disc list-inside mt-1">
                    <li>Make sure your query is related to the content in the {normalizedDataSourceType || 'data source'}</li>
                    {normalizedDataSourceType === 'pdf' && (
                      <>
                        <li>Try using specific terms that appear in the PDF document</li>
                        <li>Ask about specific sections, pages, or topics in the document</li>
                      </>
                    )}
                    {normalizedDataSourceType === 'excel' && (
                      <>
                        <li>Try referring to specific columns or data categories in the spreadsheet</li>
                        <li>Ask for specific calculations or data summaries</li>
                      </>
                    )}
                    {normalizedDataSourceType === 'database' && (
                      <>
                        <li>Try using more specific database terminology in your query</li>
                        <li>Ask about specific tables, records, or fields</li>
                      </>
                    )}
                    {normalizedDataSourceType === 'qdrant' && (
                      <>
                        <li>Try using more specific semantic search terms</li>
                        <li>Ask about concepts rather than exact matches</li>
                      </>
                    )}
                    <li>Check if the data source was properly indexed</li>
                    <li>Verify that the data source type is correctly identified (current: {normalizedDataSourceType || 'unknown'})</li>
                  </ul>
                </div>
                <div className="text-xs text-gray-500 mt-2">
                  Data source: {normalizedDataSourceType || 'unknown'}
                </div>
              </div>
            </div>
          </div>
        )}
        
        {/* Summary section - always show if available */}
        {summary && (
          <div className="section mb-6">
            <h3 className="text-lg font-semibold mb-3 text-gray-800 dark:text-gray-100 flex items-center">
              <span className="bg-purple-100 dark:bg-purple-900/30 text-purple-800 dark:text-purple-300 w-7 h-7 rounded-full flex items-center justify-center mr-2 text-sm">
                1
              </span>
              Summary & Analysis
            </h3>
              <div className="bg-white dark:bg-gray-800/90 rounded-lg shadow-sm border border-gray-100 dark:border-gray-700/80 p-5 backdrop-blur-sm">
              <div className="prose prose-sm dark:prose-invert max-w-none prose-headings:text-gray-800 dark:prose-headings:text-gray-100 prose-p:text-gray-700 dark:prose-p:text-gray-200 text-gray-800 dark:text-gray-200 prose-headings:font-semibold prose-h2:text-lg prose-h3:text-base prose-h2:mt-6 prose-h2:mb-4 prose-h3:mt-4 prose-h3:mb-2 prose-hr:my-5 prose-hr:border-gray-200 dark:prose-hr:border-gray-700">
                <MessageMarkdown content={summary} />
              </div>
            </div>
              </div>
            )}
        
        {/* Insights section */}
        {insights && insights.length > 0 && (
          <div className="section mb-6">
            <h3 className="text-lg font-semibold mb-3 text-gray-800 dark:text-gray-100 flex items-center">
              <span className="bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-300 w-7 h-7 rounded-full flex items-center justify-center mr-2 text-sm">
                {(summary ? 1 : 0) + 
                 (insights.length > 0 ? 1 : 0) + 
                 (recommendations.length > 0 ? 1 : 0) + 
                 (visualizationsData && visualizationsData.length > 0 ? visualizationsData.length : 0) + 
                 (visualizationData ? 1 : 0) + 
                 1}
              </span>
              Key Insights
            </h3>
            <div className="bg-white dark:bg-gray-800/90 rounded-lg shadow-sm border border-gray-100 dark:border-gray-700/80 p-5 backdrop-blur-sm">
              <ul className="space-y-2">
                {insights.map((insight, index) => (
                  <li key={index} className="flex items-start">
                    <span className="text-blue-500 mr-2 mt-0.5">â€¢</span>
                    <span className="text-gray-700 dark:text-gray-300">{insight}</span>
                  </li>
                ))}
              </ul>
            </div>
          </div>
        )}
        
        {/* Recommendations section if available */}
        {recommendations && recommendations.length > 0 && (
          <div className="section mb-6">
            <h3 className="text-lg font-semibold mb-3 text-gray-800 dark:text-gray-100 flex items-center">
              <span className="bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300 w-7 h-7 rounded-full flex items-center justify-center mr-2 text-sm">
                {(summary ? 1 : 0) + 
                 (insights.length > 0 ? 1 : 0) + 
                 (recommendations.length > 0 ? 1 : 0) + 
                 (visualizationsData && visualizationsData.length > 0 ? visualizationsData.length : 0) + 
                 (visualizationData ? 1 : 0) + 
                 1}
              </span>
              Recommendations
            </h3>
              <div className="bg-white dark:bg-gray-800/90 rounded-lg shadow-sm border border-gray-100 dark:border-gray-700/80 p-5 backdrop-blur-sm">
              <ul className="space-y-2">
                {recommendations.map((recommendation, index) => (
                  <li key={index} className="flex items-start">
                    <span className="text-green-500 mr-2 mt-0.5">âœ“</span>
                    <span className="text-gray-700 dark:text-gray-300">{recommendation}</span>
                  </li>
                ))}
              </ul>
            </div>
              </div>
            )}
        
        {/* Visualization slides - new section */}
        {renderVisualizationSlides()}
        
        {/* Original steps section - keep for backward compatibility */}
        {steps && steps.length > 0 && (
          <div className="section">
            {/* ... existing code ... */}
          </div>
        )}
      </div>
    </StepContext.Provider>
  );
};

export function createSampleAnalysisSteps(): AnalyticalStep[] {
  return [
    {
      id: '1',
      type: 'info',
      description: 'First, I reviewed the \'Sales\' column to determine the total sales for each segment.',
      order: 1,
      content: 'I aggregated the data by segment to calculate total sales. This allowed me to understand the overall performance of each business segment and regional market.',
      insights: [
        'Consumer segment leads with 41% of total sales',
        'North America region accounts for 52% of all sales',
        'Q4 sales were 32% higher than Q3 across all segments'
      ],
      metrics: [
        {label: 'Total Sales', value: '$7.8M'},
        {label: 'Top Segment', value: 'Consumer'},
        {label: 'YoY Growth', value: '+12.3%'}
      ],
      data: [
        {segment: 'Consumer', sales: '$3,200,000', percentage: '41%', growth: '+15.3%'},
        {segment: 'Corporate', sales: '$2,700,000', percentage: '35%', growth: '+10.1%'},
        {segment: 'Small Business', sales: '$1,900,000', percentage: '24%', growth: '+8.7%'}
      ],
      visualization: {
        type: 'pie',
        config: {
          data: [
            {name: 'Consumer', value: 41},
            {name: 'Corporate', value: 35},
            {name: 'Small Business', value: 24}
          ],
          series: [
            {dataKey: 'value', name: 'Percentage'}
          ],
          labels: {
            title: 'Sales Distribution by Segment',
            xAxis: 'Segment',
            yAxis: 'Sales (%)'
          }
        }
      }
    }
  ];
} 