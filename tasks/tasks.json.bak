{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Multi-Tenant Database Schema",
      "description": "Design and implement the PostgreSQL database schema with row-level security (RLS) to support multi-tenancy and data isolation.",
      "details": "Create Prisma schema with the following models: Organization, Client, Customer, MeterReading, TariffBlock, TariffRate, BillingPeriod, Invoice, and RoleAssignment. Implement PostgreSQL RLS policies for each table to enforce tenant isolation. Use Prisma 4.x with PostgreSQL 14+ for optimal RLS support. Implement the following RLS policies:\n\n1. For Client: `CREATE POLICY client_isolation ON \"Client\" USING (organization_id = current_setting('app.current_organization_id')::uuid)`\n2. For Customer: `CREATE POLICY customer_isolation ON \"Customer\" USING (client_id IN (SELECT id FROM \"Client\" WHERE organization_id = current_setting('app.current_organization_id')::uuid))`\n\nImplement Prisma middleware to automatically set the RLS context based on the authenticated user's organization scope.",
      "testStrategy": "Write unit tests to verify RLS policies are correctly enforced. Create test cases that attempt cross-tenant access and verify 403 errors are returned. Test database migrations to ensure they preserve RLS policies. Verify query performance with realistic data volumes.",
      "priority": "high",
      "dependencies": [],
      "status": "in-progress",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Prisma Schema with Multi-Tenant Models",
          "description": "Create the initial Prisma schema with all required models for the energy billing system, including tenant identification fields.",
          "dependencies": [],
          "details": "Define models for User, Tenant, EnergyConsumption, Billing, Payment, and other required entities. Each model should include a mandatory tenantId field for isolation. Include proper relations between models, indexes for performance, and appropriate field types. Document schema with comments explaining multi-tenant design decisions.\n<info added on 2025-06-01T15:50:39.715Z>\n## Current State Analysis\n\n**Existing Database Structure:**\n- PostgreSQL database already configured (localhost:5432, ciro_db)\n- Current schema.prisma contains basic RAG/chat system models\n- baseline.sql shows extensive existing structure with organization-based multi-tenancy partially implemented\n- Already has: organizations, organization_members, users tables with organization_id fields\n- Missing: Energy billing specific models (Customer, MeterReading, Invoice, TariffRate, etc.)\n\n**Key Findings:**\n1. Multi-tenancy foundation exists with organization_id pattern\n2. Need to extend existing structure rather than replace it\n3. Must maintain backward compatibility with existing chat/dashboard features\n4. PostgreSQL 14+ available (RLS ready)\n5. No current RLS policies implemented - need to add them\n\n**Next Steps:**\n1. Design energy billing models that integrate with existing organization structure\n2. Maintain existing User/Organization relationship\n3. Add energy-specific models: Client (energy companies), Customer, MeterReading, TariffBlock, Invoice\n4. Implement RLS policies for all tables (existing + new)\n</info added on 2025-06-01T15:50:39.715Z>\n<info added on 2025-06-01T15:52:13.505Z>\n## Schema Design Completed ✅\n\n**Comprehensive Multi-Tenant Energy Billing Schema Created:**\n\n**New Energy Models Added:**\n1. **Client** - Energy companies (EIS Power's customers) with billing configuration\n2. **Customer** - End-users within each client portal with service addresses\n3. **MeterReading** - Energy consumption data with time-of-use support\n4. **TariffRate** - Pricing structures (flat, tiered, time-of-use, demand)\n5. **TariffBlock** - Tiered pricing blocks for complex rate structures\n6. **BillingPeriod** - Billing cycles with calculated totals\n7. **Invoice** - Final bills with detailed charge breakdown\n\n**Multi-Tenancy Architecture:**\n- Organization → Client → Customer hierarchy\n- Row-level security ready with organizationId/clientId fields\n- Proper foreign key relationships maintain data integrity\n- Backward compatibility with existing RAG/chat system\n\n**Key Features Implemented:**\n- Decimal precision for financial calculations (10,2 for money, 12,3 for kWh)\n- Time-of-Use support (on-peak, off-peak, mid-peak)\n- Demand charges for commercial customers\n- Comprehensive audit trail (created_by, timestamps)\n- Status tracking for all entities\n- Flexible metadata fields for extensibility\n\n**Next Steps:**\n- Validate schema with Prisma\n- Implement RLS policies\n- Create migration scripts\n</info added on 2025-06-01T15:52:13.505Z>",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implement PostgreSQL RLS Policies",
          "description": "Create Row-Level Security policies for each table to enforce tenant isolation at the database level.",
          "dependencies": [
            1
          ],
          "details": "For each table, create RLS policies that restrict access based on tenant ID. Implement USING and WITH CHECK expressions to enforce read and write isolation. Create database functions for policy enforcement. Document each policy with security rationale. Include policies for system tables that might expose tenant data.\n<info added on 2025-06-01T15:55:47.731Z>\n## RLS Policies Implementation Complete ✅\n\n**Comprehensive RLS Security System Created:**\n\n**Security Architecture:**\n- 4 helper functions for secure session management\n- 15+ RLS policies covering all tenant-scoped tables\n- Performance-optimized with targeted indexes\n- Monitoring views and test functions included\n\n**Key Security Features:**\n1. **Complete Isolation**: Organization → Client → Customer hierarchy enforced\n2. **Defense in Depth**: SECURITY DEFINER functions prevent privilege escalation\n3. **Fail-Safe Default**: organization_id defaults to 0 (deny access) if not set\n4. **Cross-Table Protection**: Complex JOIN conditions prevent data leakage\n5. **Performance Optimized**: 10+ indexes to optimize policy queries\n\n**RLS Coverage:**\n- **Core Tables**: organizations, organization_members, users\n- **Energy Billing**: clients, customers, meter_readings, tariff_rates, billing_periods, invoices\n- **Existing System**: workspaces, files, data_sources, chat_sessions, document_chunks\n\n**Helper Functions Created:**\n- `get_current_organization_id()` - Session-based tenant context\n- `get_current_user_id()` - Current user identification  \n- `is_organization_admin()` - Role-based access control\n- `test_rls_isolation()` - Automated security testing\n\n**Ready for Testing:**\n- SQL script ready for execution: `prisma/rls-policies.sql`\n- Verification queries included for security validation\n- Performance monitoring views created\n</info added on 2025-06-01T15:55:47.731Z>",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Develop Prisma Middleware for Tenant Context",
          "description": "Create Prisma middleware to automatically inject tenant context into all database queries.",
          "dependencies": [
            1
          ],
          "details": "Implement middleware that intercepts all Prisma queries and adds tenant filtering. Create context providers to extract tenant information from authentication. Handle edge cases like system-level operations. Ensure middleware works with all Prisma operations (findMany, create, update, etc.). Include error handling for missing tenant context.\n<info added on 2025-06-01T15:58:54.304Z>\n## Prisma Middleware for Tenant Context Complete ✅\n\n**Comprehensive Tenant Context System Implemented:**\n\n**Core Components Created:**\n1. **TenantContextMiddleware** - Extracts tenant context from authenticated requests\n2. **Enhanced PrismaService** - Automatically sets PostgreSQL session variables for RLS\n3. **TenantService** - High-level utilities for tenant-scoped operations\n4. **AppModule Integration** - Middleware registered for all routes\n\n**Key Features:**\n- **AsyncLocalStorage** for request-scoped tenant context\n- **Automatic RLS Context Setting** via Prisma middleware\n- **Fail-Safe Security** with proper error handling\n- **System Operation Support** for admin/system tasks\n- **Resource Validation** utilities for access control\n\n**Middleware Architecture:**\n- Extracts organizationId and userId from authenticated user\n- Stores context in AsyncLocalStorage for the request duration\n- Prisma middleware automatically calls PostgreSQL set_config() \n- Supports both tenant-scoped and system-level operations\n\n**TenantService Utilities:**\n- `getOrganizationId()` - Safe tenant context access\n- `executeInTenantContext()` - Cross-tenant admin operations\n- `executeAsSystem()` - System operations (admin only)\n- `validateResourceAccess()` - Resource ownership validation\n- `getOrganizationStats()` - Tenant analytics\n\n**Integration Points:**\n- Registered in AppModule for all routes\n- Works with existing authentication system\n- Automatic context propagation to all Prisma queries\n- Compatible with existing chat/dashboard features\n\n**Ready for Testing:**\n- Context extraction from user.organizations\n- Session variable setting in PostgreSQL\n- RLS policy enforcement validation\n- Multi-tenant data isolation verification\n</info added on 2025-06-01T15:58:54.304Z>",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Create Database Migration Scripts",
          "description": "Develop migration scripts for schema changes and RLS policy implementation.",
          "dependencies": [
            1,
            2
          ],
          "details": "Generate initial migration for schema creation. Create separate migration for RLS policy implementation. Include rollback procedures for each migration. Test migrations in development environment. Document migration process for different environments (dev, staging, production).\n<info added on 2025-06-01T17:25:51.709Z>\n## Current State Analysis Complete ✅\n\n**Schema Analysis Results:**\n\n**Two Separate Schema Files Discovered:**\n1. `/server/prisma/schema.prisma` - Existing RAG/chat system (deployed)\n2. `/prisma/schema.prisma` - New energy billing models (not yet deployed)\n\n**Current Database State:**\n- Server schema deployed with existing migrations in `/server/prisma/migrations/`\n- Energy billing schema with comprehensive models ready for deployment\n- RLS policies already written in `/prisma/rls-policies.sql`\n\n**Migration Strategy Required:**\n1. **Schema Integration Migration** - Merge energy billing models into server schema\n2. **RLS Implementation Migration** - Apply RLS policies to all tables\n3. **Data Migration** (if needed) - Handle any existing data conflicts\n\n**Key Challenges Identified:**\n- Model conflicts: Both schemas have `users`, `organizations` models with different structures\n- ID type conflicts: Server uses Int IDs, new schema uses UUIDs in some places\n- Need to maintain backward compatibility with existing chat/RAG system\n\n**Next Steps:**\n1. Create schema integration migration to merge models safely\n2. Create RLS implementation migration with all security policies\n3. Test migrations thoroughly in development environment\n</info added on 2025-06-01T17:25:51.709Z>\n<info added on 2025-06-01T17:31:30.043Z>\n## Migration Scripts Creation Complete ✅\n\n**Major Achievements:**\n\n**1. Schema Integration Migration Created** ✅\n- Energy billing models successfully added to server Prisma schema\n- Extended Role enum with energy-specific roles (ENERGY_ADMIN, CLIENT_ADMIN, CUSTOMER_USER)\n- Updated user and organization relationships\n- Migration `20250601172703_add_energy_billing_models` generated and applied\n\n**2. RLS Implementation Migration Created** ✅\n- Comprehensive RLS policies script: `rls-policies.sql`\n- 21 tables now have RLS enabled with proper policies\n- 4 helper functions created for secure context management\n- Performance indexes added for all RLS-filtered queries\n- Security monitoring view created for ongoing audit\n\n**3. Rollback Procedures Created** ✅\n- Emergency RLS rollback script: `rollback-rls-policies.sql`\n- Can safely disable RLS without losing schema changes\n- Full documentation of rollback procedures for production\n\n**4. Comprehensive Documentation Created** ✅\n- Complete migration guide: `MIGRATION_GUIDE.md`\n- Security verification checklist\n- Environment-specific deployment procedures\n- Troubleshooting and monitoring guidance\n\n**Migration Results Verified:**\n- RLS enabled on all 18 critical tables\n- Security policies active and enforcing isolation\n- Helper functions created with SECURITY DEFINER protection\n- Performance indexes applied successfully\n- Monitoring tools functional\n\n**Ready for Next Phase:**\n- Database schema fully prepared for energy billing system\n- Multi-tenant security active and verified\n- Application integration can begin\n- Next subtask (Unit Tests) can proceed with confidence\n\n**Files Created/Modified:**\n- `server/prisma/schema.prisma` - Extended with energy billing models\n- `server/prisma/migrations/20250601172703_add_energy_billing_models/migration.sql` - Auto-generated\n- `server/prisma/migrations/20250601172703_add_energy_billing_models/rls-policies.sql` - RLS implementation\n- `server/prisma/migrations/20250601172703_add_energy_billing_models/rollback-rls-policies.sql` - Rollback script\n- `server/prisma/MIGRATION_GUIDE.md` - Complete documentation\n</info added on 2025-06-01T17:31:30.043Z>",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Implement Unit Tests for Tenant Isolation",
          "description": "Create comprehensive test suite to verify tenant data isolation and security.",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Develop tests that verify data isolation between tenants. Test direct database access and Prisma API access. Include security penetration tests attempting to bypass tenant isolation. Test edge cases like null tenant IDs or system operations. Create documentation of test results and security verification.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 2,
      "title": "Implement Role-Based Access Control System",
      "description": "Extend the existing CIRO AI authentication system to support the role hierarchy: SYSTEM_ADMIN > CLIENT_ADMIN > CUSTOMER_USER with appropriate permissions and scopes.",
      "details": "Extend the existing authentication system to include role-based access control. Use JWT tokens with role and scope claims. Implement NestJS Guards for API endpoint protection. Create the following roles and permissions:\n\n1. SYSTEM_ADMIN: Full access to all resources\n2. CLIENT_ADMIN: Access to own client data and all customer data under that client\n3. CUSTOMER_USER: Access only to own customer data\n\nImplement using @nestjs/passport with JWT strategy. Use custom decorators for role checks:\n```typescript\n@UseGuards(JwtAuthGuard, RolesGuard)\n@Roles('CLIENT_ADMIN')\n@Controller('customers')\nexport class CustomerController { ... }\n```\n\nStore role assignments in the RoleAssignment table with user_id, role, and scope fields.",
      "testStrategy": "Create unit tests for auth guards and role decorators. Test each role's access to various endpoints. Verify cross-tenant access prevention. Test token expiration and refresh flows. Create integration tests that simulate complete authentication and authorization workflows.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Setup NestJS Backend Project Structure",
      "description": "Initialize the NestJS backend project with proper module organization, Prisma integration, and configuration for multi-tenant support.",
      "details": "Initialize a NestJS project using NestJS CLI v9.x or later. Organize the project into the following modules: auth, clients, customers, meter-readings, tariffs, billing, invoices, and admin. Set up Prisma ORM integration using @prisma/client and nest-prisma. Configure environment variables for different deployment environments. Implement a global exception filter for standardized error responses. Set up logging with Winston or Pino. Configure CORS for frontend integration. Example structure:\n\n```\nsrc/\n  modules/\n    auth/\n    clients/\n    customers/\n    meter-readings/\n    tariffs/\n    billing/\n    invoices/\n    admin/\n  common/\n    guards/\n    filters/\n    interceptors/\n    decorators/\n  config/\n  prisma/\n```\n\nImplement a PrismaService that extends PrismaClient with middleware for tenant isolation.",
      "testStrategy": "Create unit tests for each module's services. Test the global exception filter with various error scenarios. Verify environment configuration loading. Test Prisma connection and middleware functionality. Ensure proper module isolation and dependency injection.",
      "priority": "high",
      "dependencies": [
        1,
        2
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Setup React Frontend Project Structure",
      "description": "Initialize the React frontend project with Tailwind CSS, shadcn/ui components, and proper organization for multi-tenant UI.",
      "details": "Create a React project using Vite for faster development. Install and configure Tailwind CSS v3.x with shadcn/ui components. Set up the project structure with the following directories:\n\n```\nsrc/\n  components/\n    ui/ (shadcn components)\n    layout/\n    forms/\n    charts/ (ECharts wrappers)\n  features/\n    auth/\n    dashboard/\n    customers/\n    billing/\n    admin/\n  hooks/\n  services/\n  utils/\n  contexts/\n  types/\n```\n\nConfigure React Router v6.x for navigation. Set up authentication context for storing user session and role information. Implement a theme provider for consistent styling. Configure Axios for API requests with interceptors for authentication headers.",
      "testStrategy": "Set up Jest and React Testing Library for component testing. Create tests for key UI components. Test routing and protected routes. Verify authentication flows in the UI. Test responsive design across different screen sizes.",
      "priority": "high",
      "dependencies": [],
      "status": "in-progress",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Implement Customer Data Model and API",
      "description": "Create the customer data model, API endpoints, and services for managing customer profiles, including NIT, contracts, addresses, and power ratings.",
      "details": "Implement the Customer model in Prisma with fields for NIT (tax ID), company name, address, contact information, power ratings, and associated meters. Create the following API endpoints:\n\n1. GET /v1/customers - List customers with pagination and filtering\n2. GET /v1/customers/:id - Get customer details\n3. POST /v1/customers - Create a new customer\n4. PUT /v1/customers/:id - Update customer details\n5. DELETE /v1/customers/:id - Delete a customer\n\nImplement validation using class-validator. Ensure all endpoints respect RLS policies. Example Customer model:\n\n```typescript\nmodel Customer {\n  id          String   @id @default(uuid())\n  clientId    String\n  client      Client   @relation(fields: [clientId], references: [id])\n  nit         String\n  name        String\n  address     String\n  powerRating Float\n  contactName String?\n  contactEmail String?\n  contactPhone String?\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n  meters      Meter[]\n  invoices    Invoice[]\n  \n  @@index([clientId])\n}\n```",
      "testStrategy": "Write unit tests for customer service methods. Test API endpoints with various input scenarios. Verify validation rules are enforced. Test RLS policies to ensure customers are only accessible by authorized users. Test performance with large customer datasets.",
      "priority": "high",
      "dependencies": [
        1,
        3
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement Bulk Customer Import Feature",
      "description": "Create a feature to import customers in bulk from Excel files, mapping to the customer data model and validating input data.",
      "details": "Implement a service to process Excel files containing customer data. Use exceljs or xlsx library to parse Excel files. Create a mapping configuration to match Excel columns to customer model fields. Implement validation for required fields and data formats. Handle duplicate detection based on NIT or other unique identifiers. Create a transaction-based import process that rolls back on errors. Implement the following API endpoint:\n\n```\nPOST /v1/customers/import\n```\n\nThe endpoint should accept multipart/form-data with an Excel file. Return a detailed report of successful imports and validation errors. Process the 'Datos de clientes para facturación.xlsx' file format as specified in the PRD.",
      "testStrategy": "Test with valid and invalid Excel files. Verify all validation rules are enforced. Test duplicate handling. Verify transaction rollback on errors. Test with large files (1000+ customers) to ensure performance. Create integration tests that verify the complete import workflow.",
      "priority": "medium",
      "dependencies": [
        5
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement Meter Management System",
      "description": "Create the meter data model, API endpoints, and services for managing meter serials, assignments to customers, and configuration.",
      "details": "Implement the Meter model in Prisma with fields for serial number, type, status, and customer association. Create API endpoints for meter CRUD operations. Implement validation for meter serial formats. Create a service for assigning meters to customers. Example Meter model:\n\n```typescript\nmodel Meter {\n  id          String   @id @default(uuid())\n  serial      String   @unique\n  customerId  String\n  customer    Customer @relation(fields: [customerId], references: [id])\n  type        String   // e.g., 'INTERVAL', 'SMART'\n  status      String   // e.g., 'ACTIVE', 'INACTIVE'\n  lossFactor  Float    @default(1.0)\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n  readings    MeterReading[]\n  \n  @@index([customerId])\n  @@index([serial])\n}\n```\n\nImplement the following API endpoints:\n1. GET /v1/meters - List meters with filtering\n2. POST /v1/meters - Create a new meter\n3. PUT /v1/meters/:id - Update meter details\n4. DELETE /v1/meters/:id - Delete a meter\n5. POST /v1/meters/:id/assign - Assign meter to a customer",
      "testStrategy": "Write unit tests for meter service methods. Test API endpoints with various input scenarios. Verify validation rules for meter serials. Test meter assignment and reassignment workflows. Verify RLS policies to ensure meters are only accessible by authorized users.",
      "priority": "high",
      "dependencies": [
        5
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement Tariff Configuration System",
      "description": "Create the tariff data models, API endpoints, and services for managing time-of-use blocks, rates, and customer-specific tariff assignments.",
      "details": "Implement TariffBlock and TariffRate models in Prisma. TariffBlock should define time periods (VALLE, RESTO, PUNTA) with start/end times. TariffRate should define pricing for energy and demand charges with validity periods. Create API endpoints for tariff management. Implement a service for assigning tariffs to customers. Example models:\n\n```typescript\nmodel TariffBlock {\n  id          String   @id @default(uuid())\n  clientId    String\n  client      Client   @relation(fields: [clientId], references: [id])\n  name        String   // e.g., 'VALLE', 'RESTO', 'PUNTA'\n  startHour   Int\n  startMinute Int\n  endHour     Int\n  endMinute   Int\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n  rates       TariffRate[]\n  \n  @@index([clientId])\n}\n\nmodel TariffRate {\n  id            String   @id @default(uuid())\n  blockId       String\n  block         TariffBlock @relation(fields: [blockId], references: [id])\n  energyRate    Float    // per kWh\n  demandRate    Float    // per kW\n  validFrom     DateTime\n  validTo       DateTime?\n  createdAt     DateTime @default(now())\n  updatedAt     DateTime @updatedAt\n  \n  @@index([blockId])\n}\n```\n\nImplement customer-specific tariff assignments with effective dates.",
      "testStrategy": "Write unit tests for tariff service methods. Test API endpoints for tariff management. Verify time block validation (no overlaps, full day coverage). Test rate validity period handling. Verify customer tariff assignment workflows. Test with historical rate changes to ensure correct application based on dates.",
      "priority": "high",
      "dependencies": [
        5,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Meter Data Upload Wizard",
      "description": "Create a drag-and-drop Excel/CSV upload wizard with preview functionality for meter reading data ingestion.",
      "details": "Implement a React component for drag-and-drop file uploads using react-dropzone. Create a preview component to display sample data from the uploaded file. Use exceljs or xlsx in the browser to parse Excel files. Implement sheet name to meter serial mapping based on the naming convention (e.g., \"Nodo Ateos 5614086\"). Create a validation service to check data format and completeness. Implement a progress indicator for large file uploads. The component should:\n\n1. Allow drag-and-drop of Excel/CSV files\n2. Parse and display a preview of the data\n3. Validate the format and content\n4. Show mapping between sheet names and meter serials\n5. Allow corrections to the mapping\n6. Submit the file to the backend for processing\n\nUse React Query for API integration and state management.",
      "testStrategy": "Create unit tests for the upload component. Test with various file formats and sizes. Verify preview functionality. Test validation error handling. Create integration tests for the complete upload workflow. Test with malformed files to ensure proper error handling.",
      "priority": "high",
      "dependencies": [
        4,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Implement Meter Reading Processing Service",
      "description": "Create a backend service to process uploaded meter reading files, extract 15-minute interval data, and store it in the database with time-of-use classification.",
      "details": "Implement a service to process uploaded meter reading files asynchronously using Kafka for event streaming. Parse Excel/CSV files to extract 15-minute interval data. Map readings to meters based on sheet names. Classify readings into time-of-use blocks (VALLE, RESTO, PUNTA) based on tariff configurations. Store readings in the MeterReading table. Implement validation for data quality and completeness. Example MeterReading model:\n\n```typescript\nmodel MeterReading {\n  id          String   @id @default(uuid())\n  meterId     String\n  meter       Meter    @relation(fields: [meterId], references: [id])\n  timestamp   DateTime\n  value       Float    // kWh or kW\n  readingType String   // 'ENERGY' or 'DEMAND'\n  blockType   String?  // 'VALLE', 'RESTO', 'PUNTA'\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n  \n  @@index([meterId])\n  @@index([timestamp])\n  @@index([meterId, timestamp])\n}\n```\n\nImplement the following API endpoint:\n```\nPOST /v1/meter-readings/upload\n```\n\nUse Kafka for asynchronous processing with topics for file upload events and processing status updates.",
      "testStrategy": "Write unit tests for the file parsing logic. Test time-of-use classification with various time periods. Verify data validation rules. Test with large files to ensure performance. Create integration tests for the complete processing workflow. Test error handling for malformed or incomplete data.",
      "priority": "high",
      "dependencies": [
        7,
        8
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement Time-of-Use Classification Engine",
      "description": "Create a service to classify meter readings into time-of-use blocks (VALLE, RESTO, PUNTA) based on tariff configurations and timestamp.",
      "details": "Implement a service to classify meter readings into time-of-use blocks based on the timestamp and tariff block definitions. Create an efficient algorithm to match timestamps to blocks without requiring database queries for each reading. Implement caching for tariff block definitions to improve performance. The service should:\n\n1. Load tariff block definitions for a client\n2. Create an efficient lookup structure (e.g., a map of minute-of-day to block type)\n3. Classify readings based on their timestamp\n4. Handle special cases like holidays or weekends if required\n\nExample classification logic:\n```typescript\nfunction classifyReading(timestamp: Date, blocks: TariffBlock[]): string {\n  const hour = timestamp.getHours();\n  const minute = timestamp.getMinutes();\n  const minuteOfDay = hour * 60 + minute;\n  \n  for (const block of blocks) {\n    const blockStart = block.startHour * 60 + block.startMinute;\n    const blockEnd = block.endHour * 60 + block.endMinute;\n    \n    if (blockStart <= minuteOfDay && minuteOfDay < blockEnd) {\n      return block.name;\n    }\n  }\n  \n  return 'UNKNOWN';\n}\n```",
      "testStrategy": "Write unit tests for the classification logic with various timestamps and block definitions. Test edge cases like midnight crossings. Verify performance with large datasets. Test caching mechanisms. Create integration tests that verify classification in the context of meter reading processing.",
      "priority": "medium",
      "dependencies": [
        8,
        10
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Implement Billing Period Management",
      "description": "Create the billing period data model, API endpoints, and services for managing billing cycles and triggering invoice generation.",
      "details": "Implement the BillingPeriod model in Prisma with fields for start date, end date, status, and client association. Create API endpoints for billing period management. Implement a service for creating billing periods and triggering invoice generation. Example BillingPeriod model:\n\n```typescript\nmodel BillingPeriod {\n  id          String   @id @default(uuid())\n  clientId    String\n  client      Client   @relation(fields: [clientId], references: [id])\n  startDate   DateTime\n  endDate     DateTime\n  status      String   // 'OPEN', 'PROCESSING', 'CLOSED'\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n  invoices    Invoice[]\n  \n  @@index([clientId])\n  @@index([startDate, endDate])\n}\n```\n\nImplement the following API endpoints:\n1. GET /v1/billing-periods - List billing periods\n2. POST /v1/billing-periods - Create a new billing period\n3. PUT /v1/billing-periods/:id - Update billing period details\n4. POST /v1/billing-periods/:id/close - Close a billing period\n5. POST /v1/billing-periods/:id/generate-invoices - Trigger invoice generation",
      "testStrategy": "Write unit tests for billing period service methods. Test API endpoints with various scenarios. Verify validation rules for billing period dates. Test billing period status transitions. Create integration tests for the complete billing workflow including invoice generation triggers.",
      "priority": "high",
      "dependencies": [
        5,
        8
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Implement Billing Calculation Engine",
      "description": "Create the core billing calculation engine to compute energy costs, demand charges, loss adjustments, and other components based on meter readings and tariff rates.",
      "details": "Implement a comprehensive billing calculation engine that follows the logic in the reference Excel workbook. The engine should calculate:\n\n1. Energy cost: Σ(kWh(slot) * kWhRate(block, date))\n2. Demand charge: MAX(kW(period)) * demandRate\n3. Loss adjustment: Σ(kWh) * FactorPerdidas\n4. FTPMS surcharge\n5. Deviation charge (forecast vs actual)\n6. Invoice total: energy + demand + adjustments - discounts + VAT\n\nImplement the calculation as a stateless service that takes meter readings, tariff rates, and customer configuration as inputs and produces detailed billing components as output. Use BigDecimal or equivalent for precise financial calculations. Ensure calculations match the reference implementation exactly.\n\nExample calculation flow:\n```typescript\nasync function calculateBill(customerId: string, billingPeriodId: string): Promise<BillingResult> {\n  // 1. Load customer, meters, and tariff configuration\n  // 2. Load meter readings for the billing period\n  // 3. Classify readings into time-of-use blocks\n  // 4. Calculate energy consumption per block\n  // 5. Determine peak demand\n  // 6. Apply tariff rates to consumption\n  // 7. Calculate adjustments and surcharges\n  // 8. Compute final invoice amount\n  // 9. Return detailed billing components\n}\n```",
      "testStrategy": "Write comprehensive unit tests comparing calculation results with the reference Excel workbook. Test with various tariff structures and consumption patterns. Verify mathematical precision in financial calculations. Test edge cases like missing readings or rate changes during a billing period. Create integration tests for the complete billing workflow.",
      "priority": "high",
      "dependencies": [
        8,
        10,
        11,
        12
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Time-of-Use Energy Cost Calculation",
          "description": "Develop the core logic for calculating energy costs based on time-of-use blocks and consumption data",
          "dependencies": [],
          "details": "Create functions to process consumption data across different time periods (peak, off-peak, etc.), apply appropriate rate structures from the Excel reference, handle seasonal variations in rates, and calculate the base energy charges. Ensure the implementation exactly matches the reference formulas for energy cost calculations.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Demand Charge Calculation",
          "description": "Build the system to calculate demand charges based on peak demand measurements",
          "dependencies": [
            1
          ],
          "details": "Develop algorithms to identify peak demand periods, apply tiered demand rate structures, handle ratchet demand provisions if applicable, and calculate demand charges according to the reference implementation. Include logic for different demand measurement methods (rolling window, fixed interval) as specified in the billing formulas.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement Loss Adjustment and Surcharge Calculations",
          "description": "Create the components for calculating loss adjustments, riders, and various surcharges",
          "dependencies": [
            1,
            2
          ],
          "details": "Develop functions to apply line loss factors, calculate percentage-based surcharges, implement fixed fee components, and handle any special riders or adjustments specified in the reference implementation. Ensure all calculations follow the exact formulas from the Excel reference.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Develop Invoice Total Computation",
          "description": "Create the system to aggregate all charges, apply taxes and discounts, and generate final invoice amounts",
          "dependencies": [
            3
          ],
          "details": "Implement logic to combine all calculated components (energy, demand, surcharges), apply appropriate tax calculations at different levels (item-specific vs. total bill), handle any discounts or credits, and produce the final invoice total. Ensure proper ordering of operations to match the reference implementation exactly.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Implement Financial Precision Handling",
          "description": "Develop robust decimal handling and rounding mechanisms for financial calculations",
          "dependencies": [
            4
          ],
          "details": "Create a system for managing decimal precision throughout all calculations, implement appropriate rounding rules at each calculation step as specified in the reference, handle currency formatting, and ensure no precision loss occurs during intermediate calculations. Focus on eliminating floating-point errors that could cause discrepancies with the reference implementation.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Develop Comprehensive Testing Suite",
          "description": "Create extensive tests to validate the billing engine against the reference implementation",
          "dependencies": [
            5
          ],
          "details": "Develop unit tests for each calculation component, integration tests for the full billing flow, regression tests with known billing scenarios, edge case tests for unusual rate structures or consumption patterns, and automated comparison tests against the Excel reference implementation. Include performance testing for large-scale billing operations.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 14,
      "title": "Implement Invoice Generation Service",
      "description": "Create a service to generate invoices based on billing calculations, store them in the database, and trigger PDF generation.",
      "details": "Implement the Invoice model in Prisma with fields for customer, billing period, amount details, status, and PDF link. Create a service to generate invoices based on billing calculations. Implement a queue-based approach using Kafka for asynchronous processing. Example Invoice model:\n\n```typescript\nmodel Invoice {\n  id              String   @id @default(uuid())\n  customerId      String\n  customer        Customer @relation(fields: [customerId], references: [id])\n  billingPeriodId String\n  billingPeriod   BillingPeriod @relation(fields: [billingPeriodId], references: [id])\n  invoiceNumber   String   @unique\n  issueDate       DateTime\n  dueDate         DateTime\n  energyAmount    Float\n  demandAmount    Float\n  adjustments     Float\n  discounts       Float\n  subtotal        Float\n  tax             Float\n  total           Float\n  status          String   // 'DRAFT', 'ISSUED', 'PAID'\n  pdfUrl          String?\n  createdAt       DateTime @default(now())\n  updatedAt       DateTime @updatedAt\n  \n  @@index([customerId])\n  @@index([billingPeriodId])\n}\n```\n\nImplement the following API endpoints:\n1. GET /v1/invoices - List invoices with filtering\n2. GET /v1/invoices/:id - Get invoice details\n3. POST /v1/invoices/:id/regenerate - Regenerate an invoice\n4. PUT /v1/invoices/:id/status - Update invoice status",
      "testStrategy": "Write unit tests for invoice generation service. Test API endpoints with various scenarios. Verify invoice numbering logic. Test status transitions. Create integration tests for the complete invoice generation workflow including PDF generation triggers. Verify data consistency between billing calculations and generated invoices.",
      "priority": "high",
      "dependencies": [
        12,
        13
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "Implement PDF Invoice Generation",
      "description": "Create a service to generate PDF invoices using Puppeteer with React/Handlebars templates and store them in Azure Blob storage.",
      "details": "Implement a service to generate PDF invoices using Puppeteer. Create React components or Handlebars templates for invoice layout. Set up Azure Blob storage integration for storing generated PDFs. Implement a queue-based approach using Kafka for asynchronous processing. The service should:\n\n1. Retrieve invoice data from the database\n2. Render the invoice template with the data\n3. Use Puppeteer to generate a PDF\n4. Upload the PDF to Azure Blob storage\n5. Update the invoice record with the PDF URL\n\nUse the following technologies:\n- Puppeteer v19.x or later for PDF generation\n- Azure SDK for JavaScript v12.x for Blob storage integration\n- Handlebars or React components for templating\n\nImplement corporate-styled invoice templates with configurable branding per client.",
      "testStrategy": "Write unit tests for PDF generation components. Test Azure Blob storage integration. Verify PDF content and formatting. Test with various invoice data scenarios. Create integration tests for the complete PDF generation workflow. Test performance with concurrent generation requests.",
      "priority": "medium",
      "dependencies": [
        14
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 16,
      "title": "Implement Customer Dashboard UI",
      "description": "Create the customer dashboard UI with energy consumption overview, peak demand indicators, and time-of-use breakdown visualizations.",
      "details": "Implement a React-based dashboard for customers using ECharts for visualizations. Create components for:\n\n1. Energy consumption overview with trend line\n2. Peak demand indicators with historical comparison\n3. Time-of-use breakdown in pie/donut chart\n4. Savings analysis compared to baseline periods\n\nUse React Query for data fetching and caching. Implement responsive design for various screen sizes. Use shadcn/ui components for consistent styling. Example dashboard layout:\n\n```tsx\nfunction CustomerDashboard() {\n  const { data: consumptionData } = useQuery(['consumption', customerId], fetchConsumptionData);\n  const { data: demandData } = useQuery(['demand', customerId], fetchDemandData);\n  \n  return (\n    <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n      <Card>\n        <CardHeader>\n          <CardTitle>Energy Consumption</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <ConsumptionChart data={consumptionData} />\n        </CardContent>\n      </Card>\n      \n      <Card>\n        <CardHeader>\n          <CardTitle>Peak Demand</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <DemandChart data={demandData} />\n        </CardContent>\n      </Card>\n      \n      {/* Additional dashboard cards */}\n    </div>\n  );\n}\n```",
      "testStrategy": "Write unit tests for dashboard components. Test with various data scenarios. Verify responsive design across screen sizes. Test loading states and error handling. Create integration tests for the complete dashboard experience. Test performance with large datasets.",
      "priority": "medium",
      "dependencies": [
        4,
        10
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 17,
      "title": "Implement Consumption Analytics UI",
      "description": "Create the consumption analytics UI with area charts for kWh by time-of-use blocks, column charts for monthly trends, and historical comparison tools.",
      "details": "Implement a React-based analytics page using ECharts for visualizations. Create components for:\n\n1. Area charts for kWh by time-of-use blocks\n2. Column charts for monthly consumption trends\n3. Gauge charts for peak kW demand\n4. Historical comparison tools with date range selection\n\nUse React Query for data fetching with parameterized queries for different date ranges and aggregation levels. Implement filters for time period, comparison type, and chart display options. Use shadcn/ui components for consistent styling. Example implementation:\n\n```tsx\nfunction ConsumptionAnalytics() {\n  const [dateRange, setDateRange] = useState({ start: startOfMonth(new Date()), end: endOfMonth(new Date()) });\n  const [comparisonPeriod, setComparisonPeriod] = useState('previous');\n  \n  const { data: currentData } = useQuery(\n    ['consumption', dateRange.start, dateRange.end],\n    () => fetchConsumptionData(dateRange.start, dateRange.end)\n  );\n  \n  const { data: comparisonData } = useQuery(\n    ['consumption', 'comparison', dateRange.start, dateRange.end, comparisonPeriod],\n    () => fetchComparisonData(dateRange.start, dateRange.end, comparisonPeriod)\n  );\n  \n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <DateRangePicker value={dateRange} onChange={setDateRange} />\n        <Select value={comparisonPeriod} onValueChange={setComparisonPeriod}>\n          <SelectItem value=\"previous\">Previous Period</SelectItem>\n          <SelectItem value=\"year\">Same Period Last Year</SelectItem>\n        </Select>\n      </div>\n      \n      <Card>\n        <CardHeader>\n          <CardTitle>Energy Consumption by Time-of-Use</CardTitle>\n        </CardHeader>\n        <CardContent className=\"h-80\">\n          <TimeOfUseChart currentData={currentData} comparisonData={comparisonData} />\n        </CardContent>\n      </Card>\n      \n      {/* Additional charts */}\n    </div>\n  );\n}\n```",
      "testStrategy": "Write unit tests for analytics components. Test with various data scenarios and date ranges. Verify chart rendering and interactions. Test comparison functionality. Create integration tests for the complete analytics experience. Test performance with large datasets and complex visualizations.",
      "priority": "medium",
      "dependencies": [
        4,
        10,
        16
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 18,
      "title": "Implement Customer Billing UI",
      "description": "Create the customer billing UI with invoice history table, PDF download functionality, payment status tracking, and billing breakdown transparency.",
      "details": "Implement a React-based billing page for customers. Create components for:\n\n1. Invoice history table with status indicators\n2. PDF download functionality\n3. Payment status tracking\n4. Billing breakdown visualization\n\nUse React Query for data fetching and caching. Implement a data table with sorting, filtering, and pagination. Use shadcn/ui components for consistent styling. Example implementation:\n\n```tsx\nfunction CustomerBilling() {\n  const { data: invoices, isLoading } = useQuery(['invoices', customerId], fetchInvoices);\n  \n  return (\n    <div className=\"space-y-6\">\n      <Card>\n        <CardHeader>\n          <CardTitle>Invoice History</CardTitle>\n        </CardHeader>\n        <CardContent>\n          {isLoading ? (\n            <div className=\"flex justify-center p-4\">\n              <Spinner />\n            </div>\n          ) : (\n            <Table>\n              <TableHeader>\n                <TableRow>\n                  <TableHead>Invoice #</TableHead>\n                  <TableHead>Date</TableHead>\n                  <TableHead>Amount</TableHead>\n                  <TableHead>Status</TableHead>\n                  <TableHead>Actions</TableHead>\n                </TableRow>\n              </TableHeader>\n              <TableBody>\n                {invoices.map((invoice) => (\n                  <TableRow key={invoice.id}>\n                    <TableCell>{invoice.invoiceNumber}</TableCell>\n                    <TableCell>{format(new Date(invoice.issueDate), 'MMM d, yyyy')}</TableCell>\n                    <TableCell>${invoice.total.toFixed(2)}</TableCell>\n                    <TableCell>\n                      <Badge variant={getStatusVariant(invoice.status)}>{invoice.status}</Badge>\n                    </TableCell>\n                    <TableCell>\n                      <Button variant=\"ghost\" size=\"sm\" asChild>\n                        <a href={invoice.pdfUrl} target=\"_blank\" rel=\"noopener noreferrer\">\n                          Download PDF\n                        </a>\n                      </Button>\n                    </TableCell>\n                  </TableRow>\n                ))}\n              </TableBody>\n            </Table>\n          )}\n        </CardContent>\n      </Card>\n      \n      {/* Billing breakdown visualization */}\n    </div>\n  );\n}\n```",
      "testStrategy": "Write unit tests for billing components. Test table functionality including sorting and filtering. Verify PDF download links. Test with various invoice statuses. Create integration tests for the complete billing experience. Test performance with large invoice histories.",
      "priority": "medium",
      "dependencies": [
        4,
        14,
        15
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 19,
      "title": "Implement Admin Customer Management Dashboard",
      "description": "Create the administrative interface for customer management, including customer list, details view, and bulk operations.",
      "details": "Implement a React-based admin dashboard for customer management. Create components for:\n\n1. Customer list with search, filter, and pagination\n2. Customer details view with edit functionality\n3. Bulk customer operations (import, export, status updates)\n4. Customer metrics and status indicators\n\nUse React Query for data fetching and mutations. Implement a data table with advanced filtering and sorting. Use shadcn/ui components for consistent styling. Example implementation:\n\n```tsx\nfunction AdminCustomerDashboard() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [page, setPage] = useState(1);\n  const [selectedCustomers, setSelectedCustomers] = useState([]);\n  \n  const { data, isLoading } = useQuery(\n    ['customers', searchTerm, page],\n    () => fetchCustomers({ search: searchTerm, page, limit: 10 })\n  );\n  \n  const importMutation = useMutation(importCustomers, {\n    onSuccess: () => {\n      queryClient.invalidateQueries(['customers']);\n      toast.success('Customers imported successfully');\n    },\n  });\n  \n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex items-center gap-2\">\n          <Input\n            placeholder=\"Search customers...\"\n            value={searchTerm}\n            onChange={(e) => setSearchTerm(e.target.value)}\n          />\n          <Button variant=\"outline\">Search</Button>\n        </div>\n        \n        <div className=\"flex items-center gap-2\">\n          <FileUpload\n            accept=\".xlsx,.csv\"\n            onUpload={(file) => importMutation.mutate(file)}\n            loading={importMutation.isLoading}\n          >\n            Import Customers\n          </FileUpload>\n          <Button\n            variant=\"outline\"\n            disabled={selectedCustomers.length === 0}\n          >\n            Export Selected\n          </Button>\n        </div>\n      </div>\n      \n      {/* Customer table */}\n      \n      {/* Pagination */}\n    </div>\n  );\n}\n```",
      "testStrategy": "Write unit tests for admin dashboard components. Test search and filter functionality. Verify bulk operations like import and export. Test with various permission levels to ensure proper access control. Create integration tests for the complete admin experience. Test performance with large customer datasets.",
      "priority": "medium",
      "dependencies": [
        4,
        5,
        6
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 20,
      "title": "Implement Admin Meter Data Upload Interface",
      "description": "Create the administrative interface for uploading and managing meter data, including validation, processing status, and error handling.",
      "details": "Implement a React-based admin interface for meter data uploads. Create components for:\n\n1. Drag-and-drop file upload with progress indicator\n2. File validation and preview\n3. Processing status monitoring\n4. Error handling and resolution\n\nUse React Query for data fetching and mutations. Implement WebSocket integration for real-time status updates. Use shadcn/ui components for consistent styling. Example implementation:\n\n```tsx\nfunction AdminMeterUpload() {\n  const [files, setFiles] = useState([]);\n  const [uploadProgress, setUploadProgress] = useState({});\n  \n  const uploadMutation = useMutation(uploadMeterData, {\n    onSuccess: (data) => {\n      queryClient.invalidateQueries(['uploads']);\n      toast.success('Upload started successfully');\n    },\n  });\n  \n  // WebSocket connection for real-time status updates\n  useEffect(() => {\n    const socket = new WebSocket(WS_URL);\n    \n    socket.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      if (data.type === 'UPLOAD_PROGRESS') {\n        setUploadProgress(prev => ({\n          ...prev,\n          [data.uploadId]: data.progress\n        }));\n      }\n    };\n    \n    return () => socket.close();\n  }, []);\n  \n  const handleUpload = async () => {\n    for (const file of files) {\n      uploadMutation.mutate(file);\n    }\n  };\n  \n  return (\n    <div className=\"space-y-6\">\n      <Card>\n        <CardHeader>\n          <CardTitle>Upload Meter Data</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <FileDropzone\n            accept=\".xlsx,.csv\"\n            onDrop={(acceptedFiles) => setFiles(acceptedFiles)}\n            multiple\n          />\n          \n          {files.length > 0 && (\n            <div className=\"mt-4\">\n              <h3 className=\"text-lg font-medium\">Selected Files</h3>\n              <ul className=\"mt-2 space-y-2\">\n                {files.map((file) => (\n                  <li key={file.name} className=\"flex items-center justify-between\">\n                    <span>{file.name}</span>\n                    <span>{formatBytes(file.size)}</span>\n                  </li>\n                ))}\n              </ul>\n              \n              <Button\n                className=\"mt-4\"\n                onClick={handleUpload}\n                loading={uploadMutation.isLoading}\n              >\n                Upload Files\n              </Button>\n            </div>\n          )}\n        </CardContent>\n      </Card>\n      \n      {/* Upload history and status */}\n    </div>\n  );\n}\n```",
      "testStrategy": "Write unit tests for upload interface components. Test file validation and preview functionality. Verify WebSocket integration for real-time updates. Test error handling and recovery workflows. Create integration tests for the complete upload experience. Test with various file formats and sizes.",
      "priority": "medium",
      "dependencies": [
        4,
        9,
        10
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 21,
      "title": "Implement Admin Billing Management Interface",
      "description": "Create the administrative interface for managing billing periods, triggering invoice generation, and monitoring billing status.",
      "details": "Implement a React-based admin interface for billing management. Create components for:\n\n1. Billing period creation and management\n2. Invoice generation triggers\n3. Billing status monitoring\n4. Error handling and resolution\n\nUse React Query for data fetching and mutations. Implement confirmation dialogs for critical actions. Use shadcn/ui components for consistent styling. Example implementation:\n\n```tsx\nfunction AdminBillingManagement() {\n  const { data: billingPeriods, isLoading } = useQuery(['billing-periods'], fetchBillingPeriods);\n  \n  const createBillingPeriodMutation = useMutation(createBillingPeriod, {\n    onSuccess: () => {\n      queryClient.invalidateQueries(['billing-periods']);\n      toast.success('Billing period created successfully');\n    },\n  });\n  \n  const generateInvoicesMutation = useMutation(generateInvoices, {\n    onSuccess: () => {\n      queryClient.invalidateQueries(['billing-periods']);\n      toast.success('Invoice generation started');\n    },\n  });\n  \n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <h2 className=\"text-2xl font-bold\">Billing Periods</h2>\n        <Button onClick={() => setShowCreateDialog(true)}>Create Billing Period</Button>\n      </div>\n      \n      {isLoading ? (\n        <div className=\"flex justify-center p-4\">\n          <Spinner />\n        </div>\n      ) : (\n        <Table>\n          <TableHeader>\n            <TableRow>\n              <TableHead>Period</TableHead>\n              <TableHead>Start Date</TableHead>\n              <TableHead>End Date</TableHead>\n              <TableHead>Status</TableHead>\n              <TableHead>Actions</TableHead>\n            </TableRow>\n          </TableHeader>\n          <TableBody>\n            {billingPeriods.map((period) => (\n              <TableRow key={period.id}>\n                <TableCell>{period.name}</TableCell>\n                <TableCell>{format(new Date(period.startDate), 'MMM d, yyyy')}</TableCell>\n                <TableCell>{format(new Date(period.endDate), 'MMM d, yyyy')}</TableCell>\n                <TableCell>\n                  <Badge variant={getStatusVariant(period.status)}>{period.status}</Badge>\n                </TableCell>\n                <TableCell>\n                  <div className=\"flex items-center gap-2\">\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      disabled={period.status !== 'OPEN'}\n                      onClick={() => generateInvoicesMutation.mutate(period.id)}\n                    >\n                      Generate Invoices\n                    </Button>\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      disabled={period.status !== 'OPEN'}\n                      onClick={() => closeBillingPeriodMutation.mutate(period.id)}\n                    >\n                      Close Period\n                    </Button>\n                  </div>\n                </TableCell>\n              </TableRow>\n            ))}\n          </TableBody>\n        </Table>\n      )}\n      \n      {/* Create billing period dialog */}\n    </div>\n  );\n}\n```",
      "testStrategy": "Write unit tests for billing management components. Test period creation and management workflows. Verify invoice generation triggers. Test with various billing period statuses. Create integration tests for the complete billing management experience. Test error handling and recovery workflows.",
      "priority": "medium",
      "dependencies": [
        4,
        12,
        13,
        14
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 22,
      "title": "Implement Real-Time Metrics Streaming",
      "description": "Create a WebSocket-based system for streaming real-time metrics to the frontend dashboards, including live consumption monitoring and system status indicators.",
      "details": "Implement a WebSocket-based system for streaming real-time metrics to the frontend. Use NestJS WebSocket Gateway for the backend implementation. Create React hooks for WebSocket connection management. Implement the following features:\n\n1. Live consumption monitoring for meters that support it\n2. System status indicators\n3. Real-time dashboard updates\n4. Connection status management\n\nExample backend implementation:\n```typescript\n@WebSocketGateway({\n  cors: {\n    origin: '*',\n  },\n})\nexport class MetricsGateway implements OnGatewayConnection, OnGatewayDisconnect {\n  @WebSocketServer()\n  server: Server;\n  \n  private clients = new Map<string, { userId: string, clientId: string }>();\n  \n  handleConnection(client: Socket, ...args: any[]) {\n    // Authenticate client and store connection\n  }\n  \n  handleDisconnect(client: Socket) {\n    this.clients.delete(client.id);\n  }\n  \n  @SubscribeMessage('subscribe')\n  handleSubscribe(client: Socket, payload: { meterId: string }) {\n    // Subscribe client to meter updates\n  }\n  \n  // Method to broadcast metrics to subscribed clients\n  broadcastMetrics(meterId: string, data: any) {\n    // Find all clients subscribed to this meter and send updates\n  }\n}\n```\n\nExample frontend hook:\n```typescript\nfunction useMetricsSocket(meterId: string) {\n  const [data, setData] = useState(null);\n  const [status, setStatus] = useState('disconnected');\n  \n  useEffect(() => {\n    const socket = new WebSocket(WS_URL);\n    \n    socket.onopen = () => {\n      setStatus('connected');\n      socket.send(JSON.stringify({ event: 'subscribe', data: { meterId } }));\n    };\n    \n    socket.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      if (message.meterId === meterId) {\n        setData(message.data);\n      }\n    };\n    \n    socket.onclose = () => {\n      setStatus('disconnected');\n    };\n    \n    return () => socket.close();\n  }, [meterId]);\n  \n  return { data, status };\n}\n```",
      "testStrategy": "Write unit tests for WebSocket gateway and client hooks. Test connection management and subscription handling. Verify real-time data streaming with simulated meter data. Test reconnection logic. Create integration tests for the complete real-time experience. Test with multiple concurrent connections to verify scalability.",
      "priority": "low",
      "dependencies": [
        3,
        4,
        10
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 23,
      "title": "Implement System Monitoring and Health Checks",
      "description": "Create a system monitoring dashboard with health checks, error tracking, and usage analytics for administrators.",
      "details": "Implement a system monitoring dashboard for administrators. Create health check endpoints for various system components. Implement error tracking and alerting. Create usage analytics reports. Use the following technologies:\n\n1. NestJS Terminus for health checks\n2. Prometheus for metrics collection\n3. Grafana for visualization (optional)\n4. Custom error tracking and logging\n\nExample health check implementation:\n```typescript\n@Controller('health')\nexport class HealthController {\n  constructor(\n    private health: HealthCheckService,\n    private db: PrismaHealthIndicator,\n    private kafka: KafkaHealthIndicator,\n    private storage: AzureBlobHealthIndicator,\n  ) {}\n\n  @Get()\n  @Roles('SYSTEM_ADMIN')\n  check() {\n    return this.health.check([\n      () => this.db.pingCheck('database'),\n      () => this.kafka.pingCheck('kafka'),\n      () => this.storage.pingCheck('azure-blob'),\n    ]);\n  }\n}\n```\n\nImplement a React-based monitoring dashboard with the following features:\n1. System health status indicators\n2. Error logs and trends\n3. Usage analytics (active users, API calls, etc.)\n4. Performance metrics (response times, queue lengths, etc.)",
      "testStrategy": "Write unit tests for health check endpoints. Test monitoring dashboard components. Verify error tracking and alerting functionality. Test with simulated system failures to ensure proper detection and reporting. Create integration tests for the complete monitoring experience.",
      "priority": "low",
      "dependencies": [
        3,
        4
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 24,
      "title": "Implement Containerized Deployment Configuration",
      "description": "Create Docker and Kubernetes configuration for containerized deployment with zero-downtime updates and scalability.",
      "details": "Create Docker and Kubernetes configuration for containerized deployment. Implement the following:\n\n1. Dockerfile for backend and frontend\n2. Docker Compose for local development\n3. Kubernetes manifests for production deployment\n4. Helm charts for easier deployment management\n5. CI/CD pipeline configuration\n\nExample Dockerfile for backend:\n```dockerfile\nFROM node:18-alpine AS builder\n\nWORKDIR /app\n\nCOPY package.json package-lock.json ./\nRUN npm ci\n\nCOPY . .\nRUN npm run build\n\nFROM node:18-alpine AS runner\n\nWORKDIR /app\n\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY --from=builder /app/package.json ./\n\nEXPOSE 3000\nCMD [\"node\", \"dist/main.js\"]\n```\n\nExample Kubernetes deployment manifest:\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: ciro-api\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: ciro-api\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 0\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: ciro-api\n    spec:\n      containers:\n      - name: api\n        image: ${REGISTRY}/ciro-api:${TAG}\n        ports:\n        - containerPort: 3000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: ciro-secrets\n              key: database-url\n        resources:\n          requests:\n            cpu: 100m\n            memory: 256Mi\n          limits:\n            cpu: 500m\n            memory: 512Mi\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 5\n          periodSeconds: 10\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 15\n          periodSeconds: 20\n```",
      "testStrategy": "Test Docker builds for both frontend and backend. Verify Docker Compose setup for local development. Test Kubernetes deployments in a staging environment. Verify zero-downtime updates with rolling deployments. Test resource limits and scaling behavior. Create CI/CD pipeline tests to ensure automated deployment works correctly.",
      "priority": "medium",
      "dependencies": [
        3,
        4
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 25,
      "title": "Implement Comprehensive Testing Suite",
      "description": "Create a comprehensive testing suite with unit tests, integration tests, end-to-end tests, and performance tests to ensure system quality and reliability.",
      "details": "Implement a comprehensive testing strategy covering all aspects of the system. Set up the following testing frameworks and configurations:\n\n1. Backend unit tests with Jest\n2. Frontend unit tests with Jest and React Testing Library\n3. API integration tests with Supertest\n4. End-to-end tests with Cypress\n5. Performance tests with k6 or JMeter\n\nAim for 90% test coverage on billing calculations and critical business logic. Create test fixtures and factories for generating test data. Implement CI/CD integration for automated testing. Example Jest configuration for backend:\n\n```javascript\nmodule.exports = {\n  moduleFileExtensions: ['js', 'json', 'ts'],\n  rootDir: 'src',\n  testRegex: '.*\\.spec\\.ts$',\n  transform: {\n    '^.+\\.(t|j)s$': 'ts-jest',\n  },\n  collectCoverageFrom: [\n    '**/*.(t|j)s',\n    '!**/*.module.(t|j)s',\n    '!**/main.ts',\n  ],\n  coverageDirectory: '../coverage',\n  testEnvironment: 'node',\n  moduleNameMapper: {\n    '^@app/(.*)$': '<rootDir>/$1',\n  },\n};\n```\n\nExample Cypress test for invoice download:\n```javascript\ndescribe('Invoice Download', () => {\n  beforeEach(() => {\n    cy.login('customer@example.com', 'password');\n    cy.visit('/billing');\n  });\n\n  it('should download invoice PDF', () => {\n    cy.get('table').contains('tr', 'INV-001').within(() => {\n      cy.contains('Download PDF').click();\n    });\n    \n    cy.verifyDownload('INV-001.pdf');\n  });\n});\n```\n\nExample k6 performance test:\n```javascript\nimport http from 'k6/http';\nimport { check, sleep } from 'k6';\n\nexport const options = {\n  vus: 100,\n  duration: '1m',\n};\n\nexport default function () {\n  const res = http.get('https://api.example.com/v1/customers/dashboard');\n  check(res, {\n    'status is 200': (r) => r.status === 200,\n    'response time < 200ms': (r) => r.timings.duration < 200,\n  });\n  sleep(1);\n}\n```",
      "testStrategy": "Verify test coverage meets the 90% target for critical components. Test the testing infrastructure itself to ensure reliability. Create documentation for running tests locally and in CI/CD. Implement test reporting and visualization. Create a test data generation strategy for realistic test scenarios.",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    }
  ]
}