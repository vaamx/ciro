generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model automations {
  id              String        @id
  name            String
  description     String?
  config          Json?
  active          Boolean       @default(true)
  organization_id Int
  created_at      DateTime      @default(now())
  updated_at      DateTime
  organizations   organizations @relation(fields: [organization_id], references: [id], onDelete: Cascade)
}

model chat_messages {
  id            Int           @id @default(autoincrement())
  session_id    Int
  message_type  String        @db.VarChar(20)
  content       String
  metadata      Json?
  timestamp     DateTime?     @default(now()) @db.Timestamptz(6)
  position      Int?
  user_id       Int?
  updated_at    DateTime?     @default(now()) @db.Timestamptz(6)
  chat_sessions chat_sessions @relation(fields: [session_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([session_id], map: "idx_chat_messages_session_id")
}

model chat_sessions {
  id              Int             @id @default(autoincrement())
  user_id         Int
  organization_id Int?
  dashboard_id    String?         @db.VarChar(255)
  title           String          @db.VarChar(255)
  last_message    String?
  message_count   Int?            @default(0)
  created_at      DateTime?       @default(now()) @db.Timestamptz(6)
  updated_at      DateTime?       @default(now()) @db.Timestamptz(6)
  is_active       Boolean?        @default(true)
  metadata        Json?           @default("{}")
  chat_messages   chat_messages[]
  organizations   organizations?  @relation(fields: [organization_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([organization_id], map: "idx_chat_sessions_org_id")
  @@index([user_id], map: "idx_chat_sessions_user_id")
}

model conversation_participants {
  id              Int           @id @default(autoincrement())
  conversation_id Int
  user_id         Int
  created_at      DateTime?     @default(now()) @db.Timestamptz(6)
  conversations   conversations @relation(fields: [conversation_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  users           users         @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([conversation_id, user_id])
}

model conversations {
  id                        Int                         @id @default(autoincrement())
  title                     String                      @db.VarChar(255)
  created_by                Int
  organization_id           Int
  created_at                DateTime?                   @default(now()) @db.Timestamptz(6)
  updated_at                DateTime?                   @default(now()) @db.Timestamptz(6)
  conversation_participants conversation_participants[]
  users                     users                       @relation(fields: [created_by], references: [id], onDelete: Cascade, onUpdate: NoAction)
  organizations             organizations               @relation(fields: [organization_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  messages                  messages[]
}

model dashboard_widgets {
  id           Int        @id @default(autoincrement())
  dashboard_id Int
  widget_type  String
  title        String?
  size         String?
  settings     Json?      @default("{}")
  position     Json?
  created_at   DateTime   @default(now())
  updated_at   DateTime
  dashboards   dashboards @relation(fields: [dashboard_id], references: [id], onDelete: Cascade)
}

model dashboards {
  id                Int                 @id @default(autoincrement())
  name              String
  description       String?
  team              String?
  category          String?
  created_by        Int?
  organization_id   Int
  created_at        DateTime            @default(now())
  updated_at        DateTime
  dashboard_widgets dashboard_widgets[]
  users             users?              @relation(fields: [created_by], references: [id])
  organizations     organizations       @relation(fields: [organization_id], references: [id], onDelete: Cascade)
  metrics           metrics[]
}

model data_sources {
  id              Int               @id @default(autoincrement())
  name            String
  type            String
  config          Json?
  status          String
  created_at      DateTime          @default(now())
  updated_at      DateTime
  creator_id      Int
  workspace_id    Int
  users           users             @relation(fields: [creator_id], references: [id])
  organizations   organizations     @relation(fields: [workspace_id], references: [id])
  document_chunks document_chunks[]
  processing_jobs processing_jobs[]
}

model document_chunks {
  id             String       @id
  data_source_id Int
  content        String
  embedding      Json?
  metadata       Json?
  created_at     DateTime     @default(now())
  updated_at     DateTime
  data_sources   data_sources @relation(fields: [data_source_id], references: [id], onDelete: Cascade)

  @@index([data_source_id])
}

model files {
  id                String         @id
  filename          String
  original_filename String
  file_type         String
  mime_type         String
  size              BigInt
  metadata          Json?
  uploaded_by       String?
  organization_id   Int?
  created_at        DateTime       @default(now())
  updated_at        DateTime
  error             String?
  content           Bytes?
  organizations     organizations? @relation(fields: [organization_id], references: [id])
}

model messages {
  id              Int           @id @default(autoincrement())
  conversation_id Int
  user_id         Int
  content         String
  role            String        @default("user") @db.VarChar(50)
  metadata        Json?         @default("{}")
  created_at      DateTime?     @default(now()) @db.Timestamptz(6)
  updated_at      DateTime?     @default(now()) @db.Timestamptz(6)
  conversations   conversations @relation(fields: [conversation_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  users           users         @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model metrics {
  id           Int        @id @default(autoincrement())
  dashboard_id Int
  title        String
  value        String?
  type         String?
  timeframe    String?
  trend        Json?
  created_at   DateTime   @default(now())
  updated_at   DateTime
  dashboards   dashboards @relation(fields: [dashboard_id], references: [id], onDelete: Cascade)
}

model organization_members {
  user_id         Int
  organization_id Int
  joined_at       DateTime      @default(now())
  organizations   organizations @relation(fields: [organization_id], references: [id], onDelete: Cascade)
  users           users         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@id([user_id, organization_id])
}

model organizations {
  id                   Int                    @id @default(autoincrement())
  name                 String
  created_at           DateTime               @default(now())
  updated_at           DateTime
  logo_url             String?
  automations          automations[]
  chat_sessions        chat_sessions[]
  conversations        conversations[]
  dashboards           dashboards[]
  data_sources         data_sources[]
  files                files[]
  organization_members organization_members[]
  workspaces           workspaces[]
  clients              Client[]
}

model processing_jobs {
  id             String       @id
  data_source_id Int
  status         String
  file_name      String?
  s3_key         String?
  metadata       Json?
  content        String?
  file_type      String?
  progress       Float?
  error          String?
  created_at     DateTime     @default(now())
  updated_at     DateTime
  completed_at   DateTime?
  data_sources   data_sources @relation(fields: [data_source_id], references: [id], onDelete: Cascade)
}

model users {
  id                        Int                         @id @default(autoincrement())
  email                     String                      @unique
  hashed_password           String?
  name                      String?
  role                      Role                        @default(USER)
  created_at                DateTime                    @default(now())
  updated_at                DateTime
  conversation_participants conversation_participants[]
  conversations             conversations[]
  dashboards                dashboards[]
  data_sources              data_sources[]
  messages                  messages[]
  organization_members      organization_members[]
  workspaces                workspaces[]
  clientsCreated            Client[]                    @relation("ClientCreatedBy")
  customersCreated          Customer[]                  @relation("CustomerCreatedBy")
}

model workspaces {
  id              Int            @id @default(autoincrement())
  name            String         @db.VarChar(255)
  description     String?
  user_id         Int?
  organization_id Int?
  is_shared       Boolean?       @default(false)
  created_at      DateTime?      @default(now()) @db.Timestamptz(6)
  updated_at      DateTime?      @default(now()) @db.Timestamptz(6)
  organizations   organizations? @relation(fields: [organization_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  users           users?         @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([organization_id], map: "idx_workspaces_org_id")
  @@index([user_id], map: "idx_workspaces_user_id")
}

enum Role {
  USER
  ADMIN
  ENERGY_ADMIN
  CLIENT_ADMIN
  CUSTOMER_USER
}

// === ENERGY BILLING MODELS ===

// Client represents the energy companies (EIS Power's customers)
// Each client has their own portal and customer base
model Client {
  id           Int     @id @default(autoincrement())
  name         String // e.g., "ABC Manufacturing"
  code         String  @unique // Short identifier e.g., "ABC001"
  contactEmail String?
  contactPhone String?
  address      String?

  // Billing Configuration
  billingAddress String?
  billingContact String?
  billingEmail   String?

  // Multi-tenant fields
  organizationId Int
  organization   organizations @relation(fields: [organizationId], references: [id])

  // Status and metadata
  status   ClientStatus @default(ACTIVE)
  metadata Json? // Custom client settings

  // Audit fields
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById Int
  createdBy   users     @relation("ClientCreatedBy", fields: [createdById], references: [id])

  // Relations
  customers   Customer[]
  tariffRates TariffRate[]
  invoices    Invoice[]

  // Enable RLS
  @@map("clients")
}

enum ClientStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

// Customer represents end-users within each client's portal
model Customer {
  id Int @id @default(autoincrement())

  // Customer Information
  customerNumber String // Unique within client e.g., "CUST-001"
  name           String
  email          String?
  phone          String?

  // Service Address
  serviceAddress String
  city           String?
  state          String?
  zipCode        String?

  // Account Information
  accountNumber String? // Utility account number
  meterNumber   String? // Primary meter identifier

  // Multi-tenant isolation
  clientId Int
  client   Client @relation(fields: [clientId], references: [id])

  // Status and metadata
  status       CustomerStatus @default(ACTIVE)
  billingCycle BillingCycle   @default(MONTHLY)
  metadata     Json? // Custom customer settings

  // Audit fields
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById Int
  createdBy   users     @relation("CustomerCreatedBy", fields: [createdById], references: [id])

  // Relations
  meterReadings  MeterReading[]
  invoices       Invoice[]
  billingPeriods BillingPeriod[]

  // Composite unique constraint: customer number unique within client
  @@unique([clientId, customerNumber])
  @@map("customers")
}

enum CustomerStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  DISCONNECTED
}

enum BillingCycle {
  MONTHLY
  QUARTERLY
  ANNUALLY
}

// Meter readings store consumption data
model MeterReading {
  id Int @id @default(autoincrement())

  // Reading Information
  meterNumber  String
  readingDate  DateTime
  readingValue Decimal     @db.Decimal(12, 3) // kWh with 3 decimal precision
  readingType  ReadingType @default(ACTUAL)

  // Demand readings (for commercial customers)
  demandReading Decimal? @db.Decimal(12, 3) // kW demand

  // Time-of-Use periods (if applicable)
  onPeakUsage  Decimal? @db.Decimal(12, 3)
  offPeakUsage Decimal? @db.Decimal(12, 3)
  midPeakUsage Decimal? @db.Decimal(12, 3)

  // Multi-tenant isolation through customer
  customerId Int
  customer   Customer @relation(fields: [customerId], references: [id])

  // Billing period this reading belongs to
  billingPeriodId Int?
  billingPeriod   BillingPeriod? @relation(fields: [billingPeriodId], references: [id])

  // Metadata and audit
  metadata  Json? // Store additional meter data
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([customerId, meterNumber, readingDate])
  @@map("meter_readings")
}

enum ReadingType {
  ACTUAL
  ESTIMATED
  CUSTOMER_READ
}

// Tariff rates define pricing structure
model TariffRate {
  id Int @id @default(autoincrement())

  // Tariff Information
  name        String // e.g., "Residential Standard", "Commercial TOU"
  code        String // e.g., "RES-STD", "COM-TOU"
  description String?

  // Rate Structure
  rateType RateType @default(FLAT)

  // Basic rates (cents per kWh)
  energyRate Decimal @db.Decimal(8, 5) // e.g., 0.12500 = 12.5 cents

  // Time-of-Use rates (if applicable)
  onPeakRate  Decimal? @db.Decimal(8, 5)
  offPeakRate Decimal? @db.Decimal(8, 5)
  midPeakRate Decimal? @db.Decimal(8, 5)

  // Demand charges ($/kW)
  demandRate Decimal? @db.Decimal(8, 2)

  // Fixed charges
  monthlyCharge Decimal? @db.Decimal(8, 2) // Monthly service charge
  connectionFee Decimal? @db.Decimal(8, 2) // One-time connection fee

  // Tiered rate blocks (for tiered pricing)
  tierBlocks TariffBlock[]

  // Multi-tenant isolation
  clientId Int
  client   Client @relation(fields: [clientId], references: [id])

  // Effective dates
  effectiveFrom DateTime
  effectiveTo   DateTime?

  // Status and metadata
  status   TariffStatus @default(ACTIVE)
  metadata Json? // Additional tariff configuration

  // Audit fields
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  billingPeriods BillingPeriod[]

  @@unique([clientId, code])
  @@map("tariff_rates")
}

enum RateType {
  FLAT
  TIERED
  TIME_OF_USE
  DEMAND
}

enum TariffStatus {
  DRAFT
  ACTIVE
  INACTIVE
  ARCHIVED
}

// Tariff blocks for tiered pricing
model TariffBlock {
  id Int @id @default(autoincrement())

  // Block Information
  blockNumber Int // 1, 2, 3, etc.
  fromKwh     Decimal @db.Decimal(12, 3) // Starting kWh for this tier
  toKwh       Decimal? @db.Decimal(12, 3) // Ending kWh (null for last tier)
  rate        Decimal @db.Decimal(8, 5) // Rate for this tier (cents per kWh)

  // Relation to tariff
  tariffRateId Int
  tariffRate   TariffRate @relation(fields: [tariffRateId], references: [id])

  @@unique([tariffRateId, blockNumber])
  @@map("tariff_blocks")
}

// Billing periods track billing cycles
model BillingPeriod {
  id Int @id @default(autoincrement())

  // Period Information
  startDate DateTime
  endDate   DateTime
  dueDate   DateTime

  // Billing totals (calculated)
  totalKwh    Decimal? @db.Decimal(12, 3)
  totalAmount Decimal? @db.Decimal(10, 2)

  // Multi-tenant isolation through customer
  customerId Int
  customer   Customer @relation(fields: [customerId], references: [id])

  // Tariff used for this billing period
  tariffRateId Int?
  tariffRate   TariffRate? @relation(fields: [tariffRateId], references: [id])

  // Status
  status BillingStatus @default(DRAFT)

  // Audit fields
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  meterReadings MeterReading[]
  invoice       Invoice?

  @@unique([customerId, startDate])
  @@map("billing_periods")
}

enum BillingStatus {
  DRAFT
  CALCULATED
  INVOICED
  PAID
  OVERDUE
  CANCELLED
}

// Invoice represents final bills
model Invoice {
  id Int @id @default(autoincrement())

  // Invoice Information
  invoiceNumber String // e.g., "INV-2024-001"
  invoiceDate   DateTime
  dueDate       DateTime

  // Amounts (all in dollars)
  energyCharges  Decimal @db.Decimal(10, 2)
  demandCharges  Decimal @db.Decimal(10, 2) @default(0)
  taxes          Decimal @db.Decimal(10, 2) @default(0)
  adjustments    Decimal @db.Decimal(10, 2) @default(0)
  totalAmount    Decimal @db.Decimal(10, 2)

  // Usage summary
  totalKwh      Decimal  @db.Decimal(12, 3)
  peakDemand    Decimal? @db.Decimal(12, 3)
  billingDays   Int
  averageDailyUsage Decimal? @db.Decimal(12, 3)

  // Multi-tenant isolation through customer
  customerId Int
  customer   Customer @relation(fields: [customerId], references: [id])

  // Relations
  billingPeriodId Int       @unique
  billingPeriod   BillingPeriod @relation(fields: [billingPeriodId], references: [id])

  // Multi-tenant through client (for easy queries)
  clientId Int
  client   Client @relation(fields: [clientId], references: [id])

  // PDF storage
  pdfUrl String? // URL to generated PDF

  // Status and metadata
  status   InvoiceStatus @default(DRAFT)
  metadata Json? // Additional invoice data

  // Payment tracking
  paidDate   DateTime?
  paidAmount Decimal? @db.Decimal(10, 2)

  // Audit fields
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([clientId, invoiceNumber])
  @@map("invoices")
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  OVERDUE
  CANCELLED
  REFUNDED
}
